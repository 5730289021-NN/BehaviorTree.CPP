{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home About this library This C++ library provides a framework to create BehaviorTrees. It was designed to be flexible, easy to use and fast. Even if our main use-case is robotics , you can use this library to build AI for games , or to replace Finite State Machines in you application. BehaviorTree.CPP has many interesting features, when compared to other implementations: It makes asynchronous Actions, i.e. non-blocking, a first-class citizen. It allows the creation of trees at run-time, using a textual representation (XML). You can link staticaly your custom TreeNodes or convert them into plugins which are loaded at run-time. It includes a logging/profiling infrastructure that allows the user to visualize, record, replay and analyze state transitions. What is a Behavior Tree? A Behavior Tree ( BT ) is a way to structure the switching between different tasks in an autonomous agent, such as a robot or a virtual entity in a computer game. BTs are a very efficient way of creating complex systems that are both modular and reactive. These properties are crucial in many applications, which has led to the spread of BT from computer game programming to many branches of AI and Robotics. If you are already familiar with Finite State Machines ( FSM ), you will easily grasp most of the concepts but, hopefully, you will find that BTs are more expressive and easier to reason about. The main advantages of Behavior Trees, when compared to FSMs are: They are intrinsically Hierarchical : this means that we can compose complex behaviors including entire trees as sub-branches of a bigger tree. For instance, the behavior \"Fetch Beer\" may reuse in one of its nodes the tree \"Grasp Object\". Their graphical representation has a semantic meaning : it is easier to \"read\" a BT and understand the corresponding workflow. State transitions in FSMs, by comparisons, are harder to understand both in their textual and graphical representation. They are more expressive : Ready to use ControlNodes and DecoratorNodes make possible to express more complex control flows. The user can extend the \"vocabulary\" with his/her own custom nodes. \"Ok, but WHY do we need BehaviorTrees (or FSM)?\" Many software systems, robotics being a notable example, are inherently complex. The usual approach to manage complexity, heterogeneity and scalability is to use the concept of Component Based Software Engineering . Any existing middleware for robotics took this approach either informally or formally, being ROS , YARP and SmartSoft some notable examples. A \"good\" software architecture should have the following characteristics: Modularity. Reusability of components. Composability. Good separation of concerns. If we don't keep these concepts in mind from the very beginning, we create software modules/components which are highly coupled to a particular application, instead of being reusable. Frequently, the concern of Coordination is mixed with Computation . In other words, people address the problems of coordinating actions and take decisions locally. The business logic becomes \"spread\" in many locations and it is hard for the developer to reason about it and to debug errors in the control flow. To achieve strong separation of concerns it is better to centralize the business logic in a single location. Finite State Machines were created specifically with this goal in mind, but in the recent years Behavior Trees gained popularity, especially in the game industry.","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#about-this-library","text":"This C++ library provides a framework to create BehaviorTrees. It was designed to be flexible, easy to use and fast. Even if our main use-case is robotics , you can use this library to build AI for games , or to replace Finite State Machines in you application. BehaviorTree.CPP has many interesting features, when compared to other implementations: It makes asynchronous Actions, i.e. non-blocking, a first-class citizen. It allows the creation of trees at run-time, using a textual representation (XML). You can link staticaly your custom TreeNodes or convert them into plugins which are loaded at run-time. It includes a logging/profiling infrastructure that allows the user to visualize, record, replay and analyze state transitions.","title":"About this library"},{"location":"#what-is-a-behavior-tree","text":"A Behavior Tree ( BT ) is a way to structure the switching between different tasks in an autonomous agent, such as a robot or a virtual entity in a computer game. BTs are a very efficient way of creating complex systems that are both modular and reactive. These properties are crucial in many applications, which has led to the spread of BT from computer game programming to many branches of AI and Robotics. If you are already familiar with Finite State Machines ( FSM ), you will easily grasp most of the concepts but, hopefully, you will find that BTs are more expressive and easier to reason about. The main advantages of Behavior Trees, when compared to FSMs are: They are intrinsically Hierarchical : this means that we can compose complex behaviors including entire trees as sub-branches of a bigger tree. For instance, the behavior \"Fetch Beer\" may reuse in one of its nodes the tree \"Grasp Object\". Their graphical representation has a semantic meaning : it is easier to \"read\" a BT and understand the corresponding workflow. State transitions in FSMs, by comparisons, are harder to understand both in their textual and graphical representation. They are more expressive : Ready to use ControlNodes and DecoratorNodes make possible to express more complex control flows. The user can extend the \"vocabulary\" with his/her own custom nodes.","title":"What is a Behavior Tree?"},{"location":"#ok-but-why-do-we-need-behaviortrees-or-fsm","text":"Many software systems, robotics being a notable example, are inherently complex. The usual approach to manage complexity, heterogeneity and scalability is to use the concept of Component Based Software Engineering . Any existing middleware for robotics took this approach either informally or formally, being ROS , YARP and SmartSoft some notable examples. A \"good\" software architecture should have the following characteristics: Modularity. Reusability of components. Composability. Good separation of concerns. If we don't keep these concepts in mind from the very beginning, we create software modules/components which are highly coupled to a particular application, instead of being reusable. Frequently, the concern of Coordination is mixed with Computation . In other words, people address the problems of coordinating actions and take decisions locally. The business logic becomes \"spread\" in many locations and it is hard for the developer to reason about it and to debug errors in the control flow. To achieve strong separation of concerns it is better to centralize the business logic in a single location. Finite State Machines were created specifically with this goal in mind, but in the recent years Behavior Trees gained popularity, especially in the game industry.","title":"\"Ok, but WHY do we need BehaviorTrees (or FSM)?\""},{"location":"BT_basics/","text":"Introduction to BTs Unlike a Finite State Machine, a Behaviour Tree is a tree of hierarchical nodes that controls the flow of decision and the execution of \"tasks\" or, as we will call them further, \" Actions \". The leaves of the tree are the actual commands, i.e. the place where our coordinating component interacts with the rest of the system. For instance, in a service-oriented architecture, the leaves would contain the \"client\" code that communicates with the \"server\" that performs the operation. In the following example, we can see two Actions executed in a sequence, DetectObject and GraspObject . The other nodes of the tree, those which are not leaves , control the \"flow of execution\". To better understand how this control flow takes place, imagine a signal called \" tick \"; it is executed at the root of the tree and it propagates through the branches until it reaches one or multiple leaves. Note The word tick will be often used as a verb (to tick / to be ticked) and it means \"To invoke the callback tick() of a TreeNode \". When a TreeNode is ticked, it returns a NodeStatus that can be either: SUCCESS FAILURE RUNNING The first two, as their names suggests, inform their parent that their operation was a success or a failure. RUNNING is returned by asynchronous nodes when their execution is not completed and they need more time to return a valid result. Asynchronous nodes can be halted . The result of a node is propagated back to its parent, that will decide which child should be ticked next or may return a result to its own parent. Types of nodes ControlNodes are nodes which can have 1 to N children. Once a tick is received, this tick may be propagated to one or more of the children. DecoratorNodes are similar to the ControlNode, but can only have a single child. ActionNodes are leaves and do not have any children. The user should implement their own ActionNodes to perform the actual tasks. ConditionNodes are equivalent to ActionNodes, but they are always atomic and synchronous, i.e. they must not return RUNNING. They should not alter the state of the system. Examples To better understand how BehaviorTrees work, let's focus on some practical examples. For the sake of simplicity we will not take into account what happens when an action returns RUNNING. We will assume that each Action is executed atomically and synchronously. First ControlNode: Sequence Let's illustrate how a BT works using the most basic and frequently used ControlNode: the SequenceNode . The children of a ControlNode are always ordered ; in the graphical representation, the order of execution is from left to right . In short: If a child returns SUCCESS, tick the next one. If a child returns FAILURE, then no more children are ticked and the Sequence returns FAILURE. If all the children return SUCCESS, then the Sequence returns SUCCESS too. Have you spotted the bug? If the action GrabBeer fails, the door of the fridge would remain open, since the last action CloseFridge is skipped. Decorators Depending on the type of DecoratorNode , the goal of this node could be either: to transform the result it received from the child to halt the execution of the child, to repeat ticking the child, depending on the type of Decorator. You can extend your grammar creating your own Decorators. The node Inverter is a Decorator that inverts the result returned by its child; An Inverter followed by the node called DoorOpen is therefore equivalent to \"Is the door closed?\". The node Retry will repeat ticking the child up to N times (3 in this case) if the child returns FAILURE. Apparently , the branch on the right side means: If the door is closed , then try to open it . Try up to 3 times , otherwise give up and return FAILURE . But... Have you spotted the bug? If DoorOpen returns FAILURE, we have the desired behaviour. But if it returns SUCCESS, the left branch fails and the entire Sequence is interrupted. We will see later how we can improve this tree. Second ControlNode: Fallback FallbackNodes , known also as \"Selectors\" , are nodes that can express, as the name suggests, fallback strategies, i.e. what to do next if a child returns FAILURE. It ticks the children in order and: If a child returns FAILURE, tick the next one. If a child returns SUCCESS, then no more children are ticked and the Fallback returns SUCCESS. If all the children return FAILURE, then the Fallback returns FAILURE too. In the next example, you can see how Sequences and Fallbacks can be combined: Is the door open? If not, try to open the door. Otherwise, if you have a key, unlock and open the door. Otherwise, smash the door. If any of these actions succeeded, then enter the room. \"Fetch me a beer\" revisited We can now improve the \"Fetch Me a Beer\" example, which left the door open if the beer was not inside the fridge. We use the color \"green\" to represent nodes which return SUCCESS and \"red\" for those which return FAILURE. Black nodes haven't been executed. Let's create an alternative tree that closes the door even when GrabBeer returns FAILURE. Both these trees will close the door of the fridge, eventually, but: the tree on the left side will always return SUCCESS, no matter if we have actually grabbed the beer. the tree on the right side will return SUCCESS if the beer was there, FAILURE otherwise. Everything works as expected if GrabBeer returns SUCCESS.","title":"Introduction to BT"},{"location":"BT_basics/#introduction-to-bts","text":"Unlike a Finite State Machine, a Behaviour Tree is a tree of hierarchical nodes that controls the flow of decision and the execution of \"tasks\" or, as we will call them further, \" Actions \". The leaves of the tree are the actual commands, i.e. the place where our coordinating component interacts with the rest of the system. For instance, in a service-oriented architecture, the leaves would contain the \"client\" code that communicates with the \"server\" that performs the operation. In the following example, we can see two Actions executed in a sequence, DetectObject and GraspObject . The other nodes of the tree, those which are not leaves , control the \"flow of execution\". To better understand how this control flow takes place, imagine a signal called \" tick \"; it is executed at the root of the tree and it propagates through the branches until it reaches one or multiple leaves. Note The word tick will be often used as a verb (to tick / to be ticked) and it means \"To invoke the callback tick() of a TreeNode \". When a TreeNode is ticked, it returns a NodeStatus that can be either: SUCCESS FAILURE RUNNING The first two, as their names suggests, inform their parent that their operation was a success or a failure. RUNNING is returned by asynchronous nodes when their execution is not completed and they need more time to return a valid result. Asynchronous nodes can be halted . The result of a node is propagated back to its parent, that will decide which child should be ticked next or may return a result to its own parent.","title":"Introduction to BTs"},{"location":"BT_basics/#types-of-nodes","text":"ControlNodes are nodes which can have 1 to N children. Once a tick is received, this tick may be propagated to one or more of the children. DecoratorNodes are similar to the ControlNode, but can only have a single child. ActionNodes are leaves and do not have any children. The user should implement their own ActionNodes to perform the actual tasks. ConditionNodes are equivalent to ActionNodes, but they are always atomic and synchronous, i.e. they must not return RUNNING. They should not alter the state of the system.","title":"Types of nodes"},{"location":"BT_basics/#examples","text":"To better understand how BehaviorTrees work, let's focus on some practical examples. For the sake of simplicity we will not take into account what happens when an action returns RUNNING. We will assume that each Action is executed atomically and synchronously.","title":"Examples"},{"location":"BT_basics/#first-controlnode-sequence","text":"Let's illustrate how a BT works using the most basic and frequently used ControlNode: the SequenceNode . The children of a ControlNode are always ordered ; in the graphical representation, the order of execution is from left to right . In short: If a child returns SUCCESS, tick the next one. If a child returns FAILURE, then no more children are ticked and the Sequence returns FAILURE. If all the children return SUCCESS, then the Sequence returns SUCCESS too. Have you spotted the bug? If the action GrabBeer fails, the door of the fridge would remain open, since the last action CloseFridge is skipped.","title":"First ControlNode: Sequence"},{"location":"BT_basics/#decorators","text":"Depending on the type of DecoratorNode , the goal of this node could be either: to transform the result it received from the child to halt the execution of the child, to repeat ticking the child, depending on the type of Decorator. You can extend your grammar creating your own Decorators. The node Inverter is a Decorator that inverts the result returned by its child; An Inverter followed by the node called DoorOpen is therefore equivalent to \"Is the door closed?\". The node Retry will repeat ticking the child up to N times (3 in this case) if the child returns FAILURE. Apparently , the branch on the right side means: If the door is closed , then try to open it . Try up to 3 times , otherwise give up and return FAILURE . But... Have you spotted the bug? If DoorOpen returns FAILURE, we have the desired behaviour. But if it returns SUCCESS, the left branch fails and the entire Sequence is interrupted. We will see later how we can improve this tree.","title":"Decorators"},{"location":"BT_basics/#second-controlnode-fallback","text":"FallbackNodes , known also as \"Selectors\" , are nodes that can express, as the name suggests, fallback strategies, i.e. what to do next if a child returns FAILURE. It ticks the children in order and: If a child returns FAILURE, tick the next one. If a child returns SUCCESS, then no more children are ticked and the Fallback returns SUCCESS. If all the children return FAILURE, then the Fallback returns FAILURE too. In the next example, you can see how Sequences and Fallbacks can be combined: Is the door open? If not, try to open the door. Otherwise, if you have a key, unlock and open the door. Otherwise, smash the door. If any of these actions succeeded, then enter the room.","title":"Second ControlNode: Fallback"},{"location":"BT_basics/#fetch-me-a-beer-revisited","text":"We can now improve the \"Fetch Me a Beer\" example, which left the door open if the beer was not inside the fridge. We use the color \"green\" to represent nodes which return SUCCESS and \"red\" for those which return FAILURE. Black nodes haven't been executed. Let's create an alternative tree that closes the door even when GrabBeer returns FAILURE. Both these trees will close the door of the fridge, eventually, but: the tree on the left side will always return SUCCESS, no matter if we have actually grabbed the beer. the tree on the right side will return SUCCESS if the beer was there, FAILURE otherwise. Everything works as expected if GrabBeer returns SUCCESS.","title":"\"Fetch me a beer\" revisited"},{"location":"DecoratorNode/","text":"Decorators A decorator is a node that can have only a single child. It is up to the Decorator to decide if, when and how many times the child should be ticked. InverterNode Tick the child once and return SUCCESS if the child failed or FAILURE if the child succeeded. If the child returns RUNNING, this node returns RUNNING too. ForceSuccessNode If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always SUCCESS. ForceFailureNode If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always FAILURE. RepeatNode Tick the child up to N times, where N is passed as a Input Port , as long as the child returns SUCCESS. Interrupt the loop if the child returns FAILURE and, in that case, return FAILURE too. If the child returns RUNNING, this node returns RUNNING too. RetryNode Tick the child up to N times, where N is passed as a Input Port , as long as the child returns FAILURE. Interrupt the loop if the child returns SUCCESS and, in that case, return SUCCESS too. If the child returns RUNNING, this node returns RUNNING too.","title":"Decorators Nodes"},{"location":"DecoratorNode/#decorators","text":"A decorator is a node that can have only a single child. It is up to the Decorator to decide if, when and how many times the child should be ticked.","title":"Decorators"},{"location":"DecoratorNode/#inverternode","text":"Tick the child once and return SUCCESS if the child failed or FAILURE if the child succeeded. If the child returns RUNNING, this node returns RUNNING too.","title":"InverterNode"},{"location":"DecoratorNode/#forcesuccessnode","text":"If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always SUCCESS.","title":"ForceSuccessNode"},{"location":"DecoratorNode/#forcefailurenode","text":"If the child returns RUNNING, this node returns RUNNING too. Otherwise, it returns always FAILURE.","title":"ForceFailureNode"},{"location":"DecoratorNode/#repeatnode","text":"Tick the child up to N times, where N is passed as a Input Port , as long as the child returns SUCCESS. Interrupt the loop if the child returns FAILURE and, in that case, return FAILURE too. If the child returns RUNNING, this node returns RUNNING too.","title":"RepeatNode"},{"location":"DecoratorNode/#retrynode","text":"Tick the child up to N times, where N is passed as a Input Port , as long as the child returns FAILURE. Interrupt the loop if the child returns SUCCESS and, in that case, return SUCCESS too. If the child returns RUNNING, this node returns RUNNING too.","title":"RetryNode"},{"location":"FallbackNode/","text":"Fallback This family of nodes are known as \"Selector\" or \"Priority\" in other frameworks. Their purpose is to try different strategies, until we find one that \"works\". Currently the framework provides two kinds of nodes: Fallback ReactiveFallback They share the following rules: Before ticking the first child, the node status becomes RUNNING . If a child returns FAILURE , the fallback ticks the next child. If the last child returns FAILURE too, all the children are halted and the fallback returns FAILURE . If a child returns SUCCESS , it stops and returns SUCCESS . All the children are halted. To understand how the two ControlNodes differ, refer to the following table: Type of ControlNode Child returns RUNNING Fallback Tick again ReactiveFallback Restart \" Restart \" means that the entire fallback is restarted from the first child of the list. \" Tick again \" means that the next time the fallback is ticked, the same child is ticked again. Previous sibling, which returned FAILURE already, are not ticked again. Fallback In this example, we try different strategies to open the door. Check first (and once) if the door is open. See the pseudocode // index is initialized to 0 in the constructor status = RUNNING ; while ( _index < number_of_children ) { child_status = child [ index ] -> tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, _index will be the same. return RUNNING ; } else if ( child_status == FAILURE ) { // continue the while loop _index ++ ; } else if ( child_status == SUCCESS ) { // Suspend execution and return SUCCESS. HaltAllChildren (); _index = 0 ; return SUCCESS ; } } // all the children returned FAILURE. Return FAILURE too. index = 0 ; HaltAllChildren (); return FAILURE ; ReactiveFallback This ControlNode is used when you want to interrupt an asynchronous child if one of the previous Conditions changes its state from FAILURE to SUCCESS. In the following example, character will sleep up to 8 hours or less, if he/she is fully rested. See the pseudocode status = RUNNING ; for ( int index = 0 ; index < number_of_children ; index ++ ) { child_status = child [ index ] -> tick (); if ( child_status == RUNNING ) { // Suspend all subsequent siblings and return RUNNING. HaltSubsequentSiblings (); return RUNNING ; } // if child_status == FAILURE, continue to tick next sibling if ( child_status == SUCCESS ) { // Suspend execution and return SUCCESS. HaltAllChildren (); return SUCCESS ; } } // all the children returned FAILURE. Return FAILURE too. HaltAllChildren (); return FAILURE ;","title":"Fallback Nodes"},{"location":"FallbackNode/#fallback","text":"This family of nodes are known as \"Selector\" or \"Priority\" in other frameworks. Their purpose is to try different strategies, until we find one that \"works\". Currently the framework provides two kinds of nodes: Fallback ReactiveFallback They share the following rules: Before ticking the first child, the node status becomes RUNNING . If a child returns FAILURE , the fallback ticks the next child. If the last child returns FAILURE too, all the children are halted and the fallback returns FAILURE . If a child returns SUCCESS , it stops and returns SUCCESS . All the children are halted. To understand how the two ControlNodes differ, refer to the following table: Type of ControlNode Child returns RUNNING Fallback Tick again ReactiveFallback Restart \" Restart \" means that the entire fallback is restarted from the first child of the list. \" Tick again \" means that the next time the fallback is ticked, the same child is ticked again. Previous sibling, which returned FAILURE already, are not ticked again.","title":"Fallback"},{"location":"FallbackNode/#fallback_1","text":"In this example, we try different strategies to open the door. Check first (and once) if the door is open. See the pseudocode // index is initialized to 0 in the constructor status = RUNNING ; while ( _index < number_of_children ) { child_status = child [ index ] -> tick (); if ( child_status == RUNNING ) { // Suspend execution and return RUNNING. // At the next tick, _index will be the same. return RUNNING ; } else if ( child_status == FAILURE ) { // continue the while loop _index ++ ; } else if ( child_status == SUCCESS ) { // Suspend execution and return SUCCESS. HaltAllChildren (); _index = 0 ; return SUCCESS ; } } // all the children returned FAILURE. Return FAILURE too. index = 0 ; HaltAllChildren (); return FAILURE ;","title":"Fallback"},{"location":"FallbackNode/#reactivefallback","text":"This ControlNode is used when you want to interrupt an asynchronous child if one of the previous Conditions changes its state from FAILURE to SUCCESS. In the following example, character will sleep up to 8 hours or less, if he/she is fully rested. See the pseudocode status = RUNNING ; for ( int index = 0 ; index < number_of_children ; index ++ ) { child_status = child [ index ] -> tick (); if ( child_status == RUNNING ) { // Suspend all subsequent siblings and return RUNNING. HaltSubsequentSiblings (); return RUNNING ; } // if child_status == FAILURE, continue to tick next sibling if ( child_status == SUCCESS ) { // Suspend execution and return SUCCESS. HaltAllChildren (); return SUCCESS ; } } // all the children returned FAILURE. Return FAILURE too. HaltAllChildren (); return FAILURE ;","title":"ReactiveFallback"},{"location":"MigrationGuide/","text":"Migration Guide from V2 to V3 The main goal of this project is to create a Behavior Tree implementation that uses the principles of Model Driven Development to separate the role of the Component Developer from the Behavior Designer and System Integrator . In practice, this means that: Custom Actions (or, in general, custom TreeNodes) must be reusable building blocks. Implement them once, reuse them many times. To build a Behavior Tree out of TreeNodes, the Behavior Designer must not need to read nor modify the source code of the a given TreeNode. There was a major design flaw that undermined these goals in version 2.x : the way the BlackBoard was used to implement DataFlow between nodes. As described in issue #18 there are several potential problems with the Blackboard approach: To know which entries of the BB are read/written, you should read the source code. As a consequence, external tools such as Groot can not know which BB entries are accessed. If there is a name clashing (multiple nodes use the same key for different purposes), the only way to fit it is modifying the source code. SMACH solved this problem using input and output ports and remapping to connect them. In the ROS community, we potentially have the same problem with topics, but tools such as rosinfo provides introspection at run-time and name clashing is avoided using remapping. This was the main reason to develop version 3.x of Behaviortree.CPP , but we also took the opportunity to do some additional refactoring to make the code more understandable. In this document we will use the following terms quite often: Composition : it refers to \"composing\" TreeNodes into Trees. In general we want a TreeNode implementation to be composition-agnostic. Model/Modelling : it is a description of a Tree or TreeNode that is sufficient (and necessary) to describe it, without knowing any additional detail about the actual C++ implementation. Blackboard, NodeParameters an DataPorts In version 2.x we had the intuition that passing one or more arguments to a TreeNode would make the node more generic and reusable. This is similar to the arguments of a function in any programming language. // with arguments GoTo ( \"kitchen\" ) //Without arguments GoToKitchen () GoToLivingRoom () GoToBedRoom1 () GoToBedroom2 () // .... To pass NodeParameters we used the Blackboard, that is nothing more than a shared key/value table, i.e. a glorified bunch of global variables. The key is a string , whilst the value is stored in a type-safe container similar to std::any or std::variant . The problem is that writing/reading in an entry of the BB was done implicitly in the source code and it was usually hard-coded. This made the TreeNode not reusable. To fix this, we still use the Blackboard under the hood, but it can not be accessed directly anymore. In version 3.x Blackboard entries can be read/written using respectively InputPorts and OutputPorts . These ports must be defined explicitly to allow remapping at run-time. Let's take a look to an example writte using the old code: <root> <BehaviorTree> <SequenceStar> <CalculateGoal/> <MoveBase goal= \"${GoalPose}\" /> </SequenceStar> </BehaviorTree> </root> using namespace BT ; //Old code (V2) NodeStatus CalculateGoal ( TreeNode & self ) { const Pose2D mygoal = { 1 , 2 , 3.14 }; // \"GoalPose\" is hardcoded... we don't like that self . blackboard () -> set ( \"GoalPose\" , mygoal ); return NodeStatus :: SUCCESS ; } class MoveBase : public AsyncActionNode { public : MoveBase ( const std :: string & name , const NodeParameters & params ) : AsyncActionNode ( name , params ) {} static const NodeParameters & requiredNodeParameters () { static NodeParameters params = {{ \"goal\" , \"0;0;0\" }}; return params ; } NodeStatus tick () { Pose2D goal ; if ( getParam < Pose2D > ( \"goal\" , goal )) { printf ( \"[ MoveBase: DONE ] \\n \" ); return NodeStatus :: SUCCESS ; } else { printf ( \"MoveBase: Failed for some reason \\n \" ); return NodeStatus :: FAILURE ; } } /// etc. }; We may notice that the NodeParameter can be remapped in the XML, but to change the key \"GoalPose\" in CalculateGoalPose we must inspect the code and modify it. In other words, NodeParameter is already a reasonably good implementation of an InputPort , but we need to introduce a consistent OutputPort too. This is the new code: <root> <BehaviorTree> <SequenceStar> <CalculateGoal target= \"{GoalPose}\" /> <MoveBase goal= \"{GoalPose}\" /> </SequenceStar> </BehaviorTree> </root> using namespace BT ; //New code (V3) class CalculateGoalPose : public SyncActionNode { public : MoveBase ( const std :: string & name , const NodeConfiguration & cfg ) : SyncActionNode ( name , cfg ) {} static PortsList providedPorts () { return { OutputPort < Pose2D > ( \"target\" ) }; } BT :: NodeStatus tick () { const Pose2D myTarget = { 1 , 2 , 3.14 }; setOutput ( \"target\" , myTarget ); return NodeStatus :: SUCCESS ; } }; class MoveBase : public AsyncActionNode { public : MoveBase ( const std :: string & name , const NodeConfiguration & config ) : AsyncActionNode ( name , config ) {} static PortsList providedPorts () { return { InputPort < Pose2D > ( \"goal\" , \"Port description\" , \"0;0;0\" ) }; } NodeStatus tick () { Pose2D goal ; if ( auto res = getInput < Pose2D > ( \"goal\" , goal )) { printf ( \"[ MoveBase: DONE ] \\n \" ); return NodeStatus :: SUCCESS ; } else { printf ( \"MoveBase: Failed. Error code: %s \\n \" , res . error ()); return NodeStatus :: FAILURE ; } } /// etc. }; The main differences are: requiredNodeParameters() was replaced by providedPorts() , that is used to declare both Inputs and Output ports alike. setOutput<>() has been introduced. The method blackboard() can not be accessed anymore. getParam<>() is now called getInput<>() to be more consistent with setOutput<>() . Furthermore, if an error occurs, we can get the error message. Remapping to a shared entry (\"GoalPose\") is done at run-time in the XML. You will never need to modify the C++ source code. SubTrees, remapping and isolated Blackboards Thanks to ports we solved the problem of reusability of single treeNodes . But we still need to address the problem of reusability of entire Trees/SubTrees . According to the rule of hierarchical composition , from the point of view of a parent Node if should not matter if the child is a LeafNode, a DecoratorNode a ControlNode or an entire Tree. As mentioned earlier, the Blackboard used to be a large key/value table. Unfortunately, this might be challenging when we reuse multiple SubTree, once again because of name clashing. The solution in version 3.x is to have a separated and isolated Blackboard for each Tree/Subtree. If we want to connect the \"internal\" ports of a SubTree with the other ports of the BB of the parent, we must explicitly do a remapping in the XML definition. No C++ code need to be modified. From the point of view of the XML, remapped ports of a SubTree looks exactly like the ports of a single node. For more details, refer to the example t06_subtree_port_remapping.cpp . ControlNodes renamed/refactored The principle of least astonishment applies to user interface and software design. A typical formulation of the principle, from 1984, is: \"If a necessary feature has a high astonishment factor, it may be necessary to redesign the feature. In my opinion, the two main building blocks of BehaviorTree.CPP, the SequenceNode and the FallbackNode have a very high astonishment factor, because they are \"reactive\" . By \"reactive\" we mean that: Children (usually ConditionNodes ) that returned a valid value, such as SUCCESS or FAILURE, might be ticked again if another child returns RUNNING. A different result in that Condition might abort/halt the RUNNING asynchronous child. The main concern of the original author of this library was to build reactive Behavior Trees (see for reference this publication ). I share this goal, but I prefer to have more explicit names, because reactive ControlNodes are useful but hard to reason about sometimes. I don't think reactive ControlNodes should be used mindlessly by default. For instance, most of the time users I talked with should have used SequenceStar instead of Sequence in many cases. I renamed the ControlNodes as follows to reflect this reality: Old Name (v2) New name (v3) Is reactive? Sequence ReactiveSequence YES SequenceStar (reset_on_failure=true) Sequence NO SequenceStar (reset_on_failure=false) SequenceStar NO Fallback ReactiveFallback YES FallbackStar Fallback NO Parallel Parallel Yes(v2) / No(v3) A reactive ParallelNode was very confusing and error prone; in most cases, what you really want is you want to use a ReactiveSequence instead. In version 2.x it was unclear what would happen if a \"reactive\" node has more than a single asynchronous child. The new recommendation is: Reactive nodes should NOT have more than a single asynchronous child . This is a very opinionated decision and for this reason it is documented but not enforced by the implementation.","title":"Migrate from Version 2.X"},{"location":"MigrationGuide/#migration-guide-from-v2-to-v3","text":"The main goal of this project is to create a Behavior Tree implementation that uses the principles of Model Driven Development to separate the role of the Component Developer from the Behavior Designer and System Integrator . In practice, this means that: Custom Actions (or, in general, custom TreeNodes) must be reusable building blocks. Implement them once, reuse them many times. To build a Behavior Tree out of TreeNodes, the Behavior Designer must not need to read nor modify the source code of the a given TreeNode. There was a major design flaw that undermined these goals in version 2.x : the way the BlackBoard was used to implement DataFlow between nodes. As described in issue #18 there are several potential problems with the Blackboard approach: To know which entries of the BB are read/written, you should read the source code. As a consequence, external tools such as Groot can not know which BB entries are accessed. If there is a name clashing (multiple nodes use the same key for different purposes), the only way to fit it is modifying the source code. SMACH solved this problem using input and output ports and remapping to connect them. In the ROS community, we potentially have the same problem with topics, but tools such as rosinfo provides introspection at run-time and name clashing is avoided using remapping. This was the main reason to develop version 3.x of Behaviortree.CPP , but we also took the opportunity to do some additional refactoring to make the code more understandable. In this document we will use the following terms quite often: Composition : it refers to \"composing\" TreeNodes into Trees. In general we want a TreeNode implementation to be composition-agnostic. Model/Modelling : it is a description of a Tree or TreeNode that is sufficient (and necessary) to describe it, without knowing any additional detail about the actual C++ implementation.","title":"Migration Guide from V2 to V3"},{"location":"MigrationGuide/#blackboard-nodeparameters-an-dataports","text":"In version 2.x we had the intuition that passing one or more arguments to a TreeNode would make the node more generic and reusable. This is similar to the arguments of a function in any programming language. // with arguments GoTo ( \"kitchen\" ) //Without arguments GoToKitchen () GoToLivingRoom () GoToBedRoom1 () GoToBedroom2 () // .... To pass NodeParameters we used the Blackboard, that is nothing more than a shared key/value table, i.e. a glorified bunch of global variables. The key is a string , whilst the value is stored in a type-safe container similar to std::any or std::variant . The problem is that writing/reading in an entry of the BB was done implicitly in the source code and it was usually hard-coded. This made the TreeNode not reusable. To fix this, we still use the Blackboard under the hood, but it can not be accessed directly anymore. In version 3.x Blackboard entries can be read/written using respectively InputPorts and OutputPorts . These ports must be defined explicitly to allow remapping at run-time. Let's take a look to an example writte using the old code: <root> <BehaviorTree> <SequenceStar> <CalculateGoal/> <MoveBase goal= \"${GoalPose}\" /> </SequenceStar> </BehaviorTree> </root> using namespace BT ; //Old code (V2) NodeStatus CalculateGoal ( TreeNode & self ) { const Pose2D mygoal = { 1 , 2 , 3.14 }; // \"GoalPose\" is hardcoded... we don't like that self . blackboard () -> set ( \"GoalPose\" , mygoal ); return NodeStatus :: SUCCESS ; } class MoveBase : public AsyncActionNode { public : MoveBase ( const std :: string & name , const NodeParameters & params ) : AsyncActionNode ( name , params ) {} static const NodeParameters & requiredNodeParameters () { static NodeParameters params = {{ \"goal\" , \"0;0;0\" }}; return params ; } NodeStatus tick () { Pose2D goal ; if ( getParam < Pose2D > ( \"goal\" , goal )) { printf ( \"[ MoveBase: DONE ] \\n \" ); return NodeStatus :: SUCCESS ; } else { printf ( \"MoveBase: Failed for some reason \\n \" ); return NodeStatus :: FAILURE ; } } /// etc. }; We may notice that the NodeParameter can be remapped in the XML, but to change the key \"GoalPose\" in CalculateGoalPose we must inspect the code and modify it. In other words, NodeParameter is already a reasonably good implementation of an InputPort , but we need to introduce a consistent OutputPort too. This is the new code: <root> <BehaviorTree> <SequenceStar> <CalculateGoal target= \"{GoalPose}\" /> <MoveBase goal= \"{GoalPose}\" /> </SequenceStar> </BehaviorTree> </root> using namespace BT ; //New code (V3) class CalculateGoalPose : public SyncActionNode { public : MoveBase ( const std :: string & name , const NodeConfiguration & cfg ) : SyncActionNode ( name , cfg ) {} static PortsList providedPorts () { return { OutputPort < Pose2D > ( \"target\" ) }; } BT :: NodeStatus tick () { const Pose2D myTarget = { 1 , 2 , 3.14 }; setOutput ( \"target\" , myTarget ); return NodeStatus :: SUCCESS ; } }; class MoveBase : public AsyncActionNode { public : MoveBase ( const std :: string & name , const NodeConfiguration & config ) : AsyncActionNode ( name , config ) {} static PortsList providedPorts () { return { InputPort < Pose2D > ( \"goal\" , \"Port description\" , \"0;0;0\" ) }; } NodeStatus tick () { Pose2D goal ; if ( auto res = getInput < Pose2D > ( \"goal\" , goal )) { printf ( \"[ MoveBase: DONE ] \\n \" ); return NodeStatus :: SUCCESS ; } else { printf ( \"MoveBase: Failed. Error code: %s \\n \" , res . error ()); return NodeStatus :: FAILURE ; } } /// etc. }; The main differences are: requiredNodeParameters() was replaced by providedPorts() , that is used to declare both Inputs and Output ports alike. setOutput<>() has been introduced. The method blackboard() can not be accessed anymore. getParam<>() is now called getInput<>() to be more consistent with setOutput<>() . Furthermore, if an error occurs, we can get the error message. Remapping to a shared entry (\"GoalPose\") is done at run-time in the XML. You will never need to modify the C++ source code.","title":"Blackboard, NodeParameters an DataPorts"},{"location":"MigrationGuide/#subtrees-remapping-and-isolated-blackboards","text":"Thanks to ports we solved the problem of reusability of single treeNodes . But we still need to address the problem of reusability of entire Trees/SubTrees . According to the rule of hierarchical composition , from the point of view of a parent Node if should not matter if the child is a LeafNode, a DecoratorNode a ControlNode or an entire Tree. As mentioned earlier, the Blackboard used to be a large key/value table. Unfortunately, this might be challenging when we reuse multiple SubTree, once again because of name clashing. The solution in version 3.x is to have a separated and isolated Blackboard for each Tree/Subtree. If we want to connect the \"internal\" ports of a SubTree with the other ports of the BB of the parent, we must explicitly do a remapping in the XML definition. No C++ code need to be modified. From the point of view of the XML, remapped ports of a SubTree looks exactly like the ports of a single node. For more details, refer to the example t06_subtree_port_remapping.cpp .","title":"SubTrees, remapping and isolated Blackboards"},{"location":"MigrationGuide/#controlnodes-renamedrefactored","text":"The principle of least astonishment applies to user interface and software design. A typical formulation of the principle, from 1984, is: \"If a necessary feature has a high astonishment factor, it may be necessary to redesign the feature. In my opinion, the two main building blocks of BehaviorTree.CPP, the SequenceNode and the FallbackNode have a very high astonishment factor, because they are \"reactive\" . By \"reactive\" we mean that: Children (usually ConditionNodes ) that returned a valid value, such as SUCCESS or FAILURE, might be ticked again if another child returns RUNNING. A different result in that Condition might abort/halt the RUNNING asynchronous child. The main concern of the original author of this library was to build reactive Behavior Trees (see for reference this publication ). I share this goal, but I prefer to have more explicit names, because reactive ControlNodes are useful but hard to reason about sometimes. I don't think reactive ControlNodes should be used mindlessly by default. For instance, most of the time users I talked with should have used SequenceStar instead of Sequence in many cases. I renamed the ControlNodes as follows to reflect this reality: Old Name (v2) New name (v3) Is reactive? Sequence ReactiveSequence YES SequenceStar (reset_on_failure=true) Sequence NO SequenceStar (reset_on_failure=false) SequenceStar NO Fallback ReactiveFallback YES FallbackStar Fallback NO Parallel Parallel Yes(v2) / No(v3) A reactive ParallelNode was very confusing and error prone; in most cases, what you really want is you want to use a ReactiveSequence instead. In version 2.x it was unclear what would happen if a \"reactive\" node has more than a single asynchronous child. The new recommendation is: Reactive nodes should NOT have more than a single asynchronous child . This is a very opinionated decision and for this reason it is documented but not enforced by the implementation.","title":"ControlNodes renamed/refactored"},{"location":"SequenceNode/","text":"Sequences A Sequence ticks all its children as long as they return SUCCESS. If any child returns FAILURE, the sequence is aborted. Currently the framework provides three kinds of nodes: Sequence SequenceStar ReactiveSequence They share the following rules: Before ticking the first child, the node status becomes RUNNING . If a child returns SUCCESS , it ticks the next child. If the last child returns SUCCESS too, all the children are halted and the sequence returns SUCCESS . To understand how the three ControlNodes differ, refer to the following table: Type of ControlNode Child returns FAILURE Child returns RUNNING Sequence Restart Tick again ReactiveSequence Restart Restart SequenceStar Tick again Tick again \" Restart \" means that the entire sequence is restarted from the first child of the list. \" Tick again \" means that the next time the sequence is ticked, the same child is ticked again. Previous sibling, which returned SUCCESS already, are not ticked again. Sequence This tree represents the behavior of a sniper in a computer game. See the pseudocode status = RUNNING ; // _index is a private member while ( _index < number_of_children ) { child_status = child [ _index ] -> tick (); if ( child_status == SUCCESS ) { _index ++ ; } else if ( child_status == RUNNING ) { // keep same index return RUNNING ; } else if ( child_status == FAILURE ) { HaltAllChildren (); _index = 0 ; return FAILURE ; } } // all the children returned success. Return SUCCESS too. HaltAllChildren (); _index = 0 ; return SUCCESS ; ReactiveSequence This node is particularly useful to continuously check Conditions; but the user should also be careful when using asynchronous children, to be sure that they are not ticked more often that expected. Let's take a look at another example: ApproachEnemy is an asynchronous action that returns RUNNING until it is, eventually, completed. The condition isEnemyVisible will be called many times and, if it becomes false (i,e, \"FAILURE\"), ApproachEnemy is halted. See the pseudocode status = RUNNING ; for ( int index = 0 ; index < number_of_children ; index ++ ) { child_status = child [ index ] -> tick (); if ( child_status == RUNNING ) { return RUNNING ; } else if ( child_status == FAILURE ) { HaltAllChildren (); return FAILURE ; } } // all the children returned success. Return SUCCESS too. HaltAllChildren (); return SUCCESS ; SequenceStar Use this ControlNode when you don't want to tick children again that already returned SUCCESS. Example : This is a patrolling agent/robot that must visit locations A, B and C only once . If the action GoTo(B) fails, GoTo(A) will not be ticked again. On the other hand, isBatteryOK must be checked at every tick, for this reason its parent must be a ReactiveSequence . See the pseudocode status = RUNNING ; // _index is a private member while ( index < number_of_children ) { child_status = child [ index ] -> tick (); if ( child_status == SUCCESS ) { _index ++ ; } else if ( child_status == RUNNING || child_status == FAILURE ) { // keep same index return child_status ; } } // all the children returned success. Return SUCCESS too. HaltAllChildren (); _index = 0 ; return SUCCESS ;","title":"Sequence Nodes"},{"location":"SequenceNode/#sequences","text":"A Sequence ticks all its children as long as they return SUCCESS. If any child returns FAILURE, the sequence is aborted. Currently the framework provides three kinds of nodes: Sequence SequenceStar ReactiveSequence They share the following rules: Before ticking the first child, the node status becomes RUNNING . If a child returns SUCCESS , it ticks the next child. If the last child returns SUCCESS too, all the children are halted and the sequence returns SUCCESS . To understand how the three ControlNodes differ, refer to the following table: Type of ControlNode Child returns FAILURE Child returns RUNNING Sequence Restart Tick again ReactiveSequence Restart Restart SequenceStar Tick again Tick again \" Restart \" means that the entire sequence is restarted from the first child of the list. \" Tick again \" means that the next time the sequence is ticked, the same child is ticked again. Previous sibling, which returned SUCCESS already, are not ticked again.","title":"Sequences"},{"location":"SequenceNode/#sequence","text":"This tree represents the behavior of a sniper in a computer game. See the pseudocode status = RUNNING ; // _index is a private member while ( _index < number_of_children ) { child_status = child [ _index ] -> tick (); if ( child_status == SUCCESS ) { _index ++ ; } else if ( child_status == RUNNING ) { // keep same index return RUNNING ; } else if ( child_status == FAILURE ) { HaltAllChildren (); _index = 0 ; return FAILURE ; } } // all the children returned success. Return SUCCESS too. HaltAllChildren (); _index = 0 ; return SUCCESS ;","title":"Sequence"},{"location":"SequenceNode/#reactivesequence","text":"This node is particularly useful to continuously check Conditions; but the user should also be careful when using asynchronous children, to be sure that they are not ticked more often that expected. Let's take a look at another example: ApproachEnemy is an asynchronous action that returns RUNNING until it is, eventually, completed. The condition isEnemyVisible will be called many times and, if it becomes false (i,e, \"FAILURE\"), ApproachEnemy is halted. See the pseudocode status = RUNNING ; for ( int index = 0 ; index < number_of_children ; index ++ ) { child_status = child [ index ] -> tick (); if ( child_status == RUNNING ) { return RUNNING ; } else if ( child_status == FAILURE ) { HaltAllChildren (); return FAILURE ; } } // all the children returned success. Return SUCCESS too. HaltAllChildren (); return SUCCESS ;","title":"ReactiveSequence"},{"location":"SequenceNode/#sequencestar","text":"Use this ControlNode when you don't want to tick children again that already returned SUCCESS. Example : This is a patrolling agent/robot that must visit locations A, B and C only once . If the action GoTo(B) fails, GoTo(A) will not be ticked again. On the other hand, isBatteryOK must be checked at every tick, for this reason its parent must be a ReactiveSequence . See the pseudocode status = RUNNING ; // _index is a private member while ( index < number_of_children ) { child_status = child [ index ] -> tick (); if ( child_status == SUCCESS ) { _index ++ ; } else if ( child_status == RUNNING || child_status == FAILURE ) { // keep same index return child_status ; } } // all the children returned success. Return SUCCESS too. HaltAllChildren (); _index = 0 ; return SUCCESS ;","title":"SequenceStar"},{"location":"getting_started/","text":"Getting started BehaviorTree.CPP is a C++ library that can be easily integrated into your favourite distributed middleware, such as ROS or SmartSoft . You can statically link it into your application (for example a game). These are the main concepts which you need to understand first. Nodes vs Trees The user must create his/her own ActionNodes and ConditionNodes (LeafNodes); this library helps you to compose them easily into trees. Think about the LeafNodes as the building blocks which you need to compose a complex system. By definition, your custom Nodes are (or should be) highly reusable . But, at the beginning, some wrapping interfaces might be needed to adapt your legacy code. The tick() callbacks Any TreeNode can be seen as a mechanism to invoke a callback , i.e. to run a piece of code . What this callback does is up to you. In most of the following tutorials, our Actions will simply print messages on console or sleep for a certain amount of time to simulate a long calculation. In production code, especially in Model Driven Development and Component Based Software Engineering, an Action/Condition would probably communicate to other components or services of the system. Inheritance vs dependency injection. To create a custom TreeNode, you should inherit from the proper class. For instance, to create your own synchronous Action, you should inherit from the class SyncActionNode . Alternatively, the library provides a mechanism to create a TreeNode passing a function pointer to a wrapper (dependency injection). This approach reduces the amount of boilerplate in your code; as a reference please look at the first tutorial and the one describing non intrusive integration with legacy code . Dataflow, Ports and Blackboard Ports are explained in detail in the second and third tutorials. For the time being, it is important to know that: A Blackboard is a key/value storage shared by all the Nodes of a Tree. Ports are a mechanism that Nodes can use to exchange information between each other. Ports are \"connected\" using the same key of the blackboard. The number, name and kind of ports of a Node must be known at compilation-time (C++); connections between ports are done at deployment-time (XML). Load trees at run-time using the XML format Despite the fact that the library is written in C++, trees themselves can be composed at run-time , more specifically, at deployment-time , since it is done only once at the beginning to instantiate the Tree. An XML format is described in details here .","title":"Getting started"},{"location":"getting_started/#getting-started","text":"BehaviorTree.CPP is a C++ library that can be easily integrated into your favourite distributed middleware, such as ROS or SmartSoft . You can statically link it into your application (for example a game). These are the main concepts which you need to understand first.","title":"Getting started"},{"location":"getting_started/#nodes-vs-trees","text":"The user must create his/her own ActionNodes and ConditionNodes (LeafNodes); this library helps you to compose them easily into trees. Think about the LeafNodes as the building blocks which you need to compose a complex system. By definition, your custom Nodes are (or should be) highly reusable . But, at the beginning, some wrapping interfaces might be needed to adapt your legacy code.","title":"Nodes vs Trees"},{"location":"getting_started/#the-tick-callbacks","text":"Any TreeNode can be seen as a mechanism to invoke a callback , i.e. to run a piece of code . What this callback does is up to you. In most of the following tutorials, our Actions will simply print messages on console or sleep for a certain amount of time to simulate a long calculation. In production code, especially in Model Driven Development and Component Based Software Engineering, an Action/Condition would probably communicate to other components or services of the system.","title":"The tick() callbacks"},{"location":"getting_started/#inheritance-vs-dependency-injection","text":"To create a custom TreeNode, you should inherit from the proper class. For instance, to create your own synchronous Action, you should inherit from the class SyncActionNode . Alternatively, the library provides a mechanism to create a TreeNode passing a function pointer to a wrapper (dependency injection). This approach reduces the amount of boilerplate in your code; as a reference please look at the first tutorial and the one describing non intrusive integration with legacy code .","title":"Inheritance vs dependency injection."},{"location":"getting_started/#dataflow-ports-and-blackboard","text":"Ports are explained in detail in the second and third tutorials. For the time being, it is important to know that: A Blackboard is a key/value storage shared by all the Nodes of a Tree. Ports are a mechanism that Nodes can use to exchange information between each other. Ports are \"connected\" using the same key of the blackboard. The number, name and kind of ports of a Node must be known at compilation-time (C++); connections between ports are done at deployment-time (XML).","title":"Dataflow, Ports and Blackboard"},{"location":"getting_started/#load-trees-at-run-time-using-the-xml-format","text":"Despite the fact that the library is written in C++, trees themselves can be composed at run-time , more specifically, at deployment-time , since it is done only once at the beginning to instantiate the Tree. An XML format is described in details here .","title":"Load trees at run-time using the XML format"},{"location":"tutorial_01_first_tree/","text":"How to create a BehaviorTree Behavior Trees, similar to State Machines, are nothing more than a mechanism to invoke callbacks at the right time under the right conditions. Further, we will use the words \"callback\" and \"tick\" interchangeably. What happens inside these callbacks is up to you. In this tutorial series, most of the time Actions will just print some information on console, but keep in mind that real \"production\" code would probably do something more complicated. How to create your own ActionNodes The default (and recommended) way to create a TreeNode is by inheritance. // Example of custom SyncActionNode (synchronous action) // without ports. class ApproachObject : public BT :: SyncActionNode { public : ApproachObject ( const std :: string & name ) : BT :: SyncActionNode ( name , {}) { } // You must override the virtual function tick() BT :: NodeStatus tick () override { std :: cout << \"ApproachObject: \" << this -> name () << std :: endl ; return BT :: NodeStatus :: SUCCESS ; } }; As you can see: Any instance of a TreeNode has a name . This identifier is meant to be human-readable and it doesn't need to be unique. The method tick() is the place where the actual Action takes place. It must always return a NodeStatus, i.e. RUNNING, SUCCESS or FAILURE. Alternatively, we can use dependecy injection to create a TreeNode given a function pointer (i.e. \"functor\"). The only requirement of the functor is to have either one of these signatures: BT :: NodeStatus myFunction () BT :: NodeStatus myFunction ( BT :: TreeNode & self ) For example: using namespace BT ; // Simple function that return a NodeStatus BT :: NodeStatus CheckBattery () { std :: cout << \"[ Battery: OK ]\" << std :: endl ; return BT :: NodeStatus :: SUCCESS ; } // We want to wrap into an ActionNode the methods open() and close() class GripperInterface { public : GripperInterface () : _open ( true ) {} NodeStatus open () { _open = true ; std :: cout << \"GripperInterface::open\" << std :: endl ; return NodeStatus :: SUCCESS ; } NodeStatus close () { std :: cout << \"GripperInterface::close\" << std :: endl ; _open = false ; return NodeStatus :: SUCCESS ; } private : bool _open ; // shared information }; We can build a SimpleActionNode from any of these functors: CheckBattery() GripperInterface::open() GripperInterface::close() Create a tree dynamically with an XML Let's consider the following XML file named my_tree.xml : <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence name= \"root_sequence\" > <CheckBattery name= \"check_battery\" /> <OpenGripper name= \"open_gripper\" /> <ApproachObject name= \"approach_object\" /> <CloseGripper name= \"close_gripper\" /> </Sequence> </BehaviorTree> </root> Note You can find more details about the XML schema here . We must first register our custom TreeNodes into the BehaviorTreeFactory and then load the XML from file or text. The identifier used in the XML must coincide with those used to register the TreeNodes. The attribute \"name\" represents the name of the instance; it is optional. #include \"behaviortree_cpp_v3/bt_factory.h\" // file that contains the custom nodes definitions #include \"dummy_nodes.h\" int main () { // We use the BehaviorTreeFactory to register our custom nodes BehaviorTreeFactory factory ; // Note: the name used to register should be the same used in the XML. using namespace DummyNodes ; // The recommended way to create a Node is through inheritance. factory . registerNodeType < ApproachObject > ( \"ApproachObject\" ); // Registering a SimpleActionNode using a function pointer. // you may also use C++11 lambdas instead of std::bind factory . registerSimpleCondition ( \"CheckBattery\" , std :: bind ( CheckBattery )); //You can also create SimpleActionNodes using methods of a class GripperInterface gripper ; factory . registerSimpleAction ( \"OpenGripper\" , std :: bind ( & GripperInterface :: open , & gripper )); factory . registerSimpleAction ( \"CloseGripper\" , std :: bind ( & GripperInterface :: close , & gripper )); // Trees are created at deployment-time (i.e. at run-time, but only // once at the beginning). // IMPORTANT: when the object \"tree\" goes out of scope, all the // TreeNodes are destroyed auto tree = factory . createTreeFromFile ( \"./my_tree.xml\" ); // To \"execute\" a Tree you need to \"tick\" it. // The tick is propagated to the children based on the logic of the tree. // In this case, the entire sequence is executed, because all the children // of the Sequence return SUCCESS. tree . tickRoot (); return 0 ; } /* Expected output: * [ Battery: OK ] GripperInterface::open ApproachObject: approach_object GripperInterface::close */","title":"Tutorial 1: Create a Tree"},{"location":"tutorial_01_first_tree/#how-to-create-a-behaviortree","text":"Behavior Trees, similar to State Machines, are nothing more than a mechanism to invoke callbacks at the right time under the right conditions. Further, we will use the words \"callback\" and \"tick\" interchangeably. What happens inside these callbacks is up to you. In this tutorial series, most of the time Actions will just print some information on console, but keep in mind that real \"production\" code would probably do something more complicated.","title":"How to create a BehaviorTree"},{"location":"tutorial_01_first_tree/#how-to-create-your-own-actionnodes","text":"The default (and recommended) way to create a TreeNode is by inheritance. // Example of custom SyncActionNode (synchronous action) // without ports. class ApproachObject : public BT :: SyncActionNode { public : ApproachObject ( const std :: string & name ) : BT :: SyncActionNode ( name , {}) { } // You must override the virtual function tick() BT :: NodeStatus tick () override { std :: cout << \"ApproachObject: \" << this -> name () << std :: endl ; return BT :: NodeStatus :: SUCCESS ; } }; As you can see: Any instance of a TreeNode has a name . This identifier is meant to be human-readable and it doesn't need to be unique. The method tick() is the place where the actual Action takes place. It must always return a NodeStatus, i.e. RUNNING, SUCCESS or FAILURE. Alternatively, we can use dependecy injection to create a TreeNode given a function pointer (i.e. \"functor\"). The only requirement of the functor is to have either one of these signatures: BT :: NodeStatus myFunction () BT :: NodeStatus myFunction ( BT :: TreeNode & self ) For example: using namespace BT ; // Simple function that return a NodeStatus BT :: NodeStatus CheckBattery () { std :: cout << \"[ Battery: OK ]\" << std :: endl ; return BT :: NodeStatus :: SUCCESS ; } // We want to wrap into an ActionNode the methods open() and close() class GripperInterface { public : GripperInterface () : _open ( true ) {} NodeStatus open () { _open = true ; std :: cout << \"GripperInterface::open\" << std :: endl ; return NodeStatus :: SUCCESS ; } NodeStatus close () { std :: cout << \"GripperInterface::close\" << std :: endl ; _open = false ; return NodeStatus :: SUCCESS ; } private : bool _open ; // shared information }; We can build a SimpleActionNode from any of these functors: CheckBattery() GripperInterface::open() GripperInterface::close()","title":"How to create your own ActionNodes"},{"location":"tutorial_01_first_tree/#create-a-tree-dynamically-with-an-xml","text":"Let's consider the following XML file named my_tree.xml : <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence name= \"root_sequence\" > <CheckBattery name= \"check_battery\" /> <OpenGripper name= \"open_gripper\" /> <ApproachObject name= \"approach_object\" /> <CloseGripper name= \"close_gripper\" /> </Sequence> </BehaviorTree> </root> Note You can find more details about the XML schema here . We must first register our custom TreeNodes into the BehaviorTreeFactory and then load the XML from file or text. The identifier used in the XML must coincide with those used to register the TreeNodes. The attribute \"name\" represents the name of the instance; it is optional. #include \"behaviortree_cpp_v3/bt_factory.h\" // file that contains the custom nodes definitions #include \"dummy_nodes.h\" int main () { // We use the BehaviorTreeFactory to register our custom nodes BehaviorTreeFactory factory ; // Note: the name used to register should be the same used in the XML. using namespace DummyNodes ; // The recommended way to create a Node is through inheritance. factory . registerNodeType < ApproachObject > ( \"ApproachObject\" ); // Registering a SimpleActionNode using a function pointer. // you may also use C++11 lambdas instead of std::bind factory . registerSimpleCondition ( \"CheckBattery\" , std :: bind ( CheckBattery )); //You can also create SimpleActionNodes using methods of a class GripperInterface gripper ; factory . registerSimpleAction ( \"OpenGripper\" , std :: bind ( & GripperInterface :: open , & gripper )); factory . registerSimpleAction ( \"CloseGripper\" , std :: bind ( & GripperInterface :: close , & gripper )); // Trees are created at deployment-time (i.e. at run-time, but only // once at the beginning). // IMPORTANT: when the object \"tree\" goes out of scope, all the // TreeNodes are destroyed auto tree = factory . createTreeFromFile ( \"./my_tree.xml\" ); // To \"execute\" a Tree you need to \"tick\" it. // The tick is propagated to the children based on the logic of the tree. // In this case, the entire sequence is executed, because all the children // of the Sequence return SUCCESS. tree . tickRoot (); return 0 ; } /* Expected output: * [ Battery: OK ] GripperInterface::open ApproachObject: approach_object GripperInterface::close */","title":"Create a tree dynamically with an XML"},{"location":"tutorial_02_basic_ports/","text":"Input and Output Ports As we explained earlier, custom TreeNodes can be used to execute an arbitrarily simple or complex piece of software. Their goal is to provide an interface with a higher level of abstraction . For this reason, they are not conceptually different from functions . Similar to functions, we often want to: pass arguments/parameters to a Node ( inputs ) get some kind of information out from a Node ( outputs ). The outputs of a node can be the inputs of another node. BehaviorTree.CPP provides a basic mechanism of dataflow through ports , that is simple to use but also flexible and type safe. Inputs ports A valid Input can be either: static strings which can be parsed by the Node, or \"pointers\" to an entry of the Blackboard, identified by a key . A \"blackboard\" is a simple key/value storage shared by all the nodes of the Tree. An \"entry\" of the Blackboard is a key/value pair . Input ports can read an entry in the Blackboard, whilst an Output port can write into an entry. Let's suppose that we want to create an ActionNode called SaySomething , that should print a given string on std::cout . Such a string will be passed using an input port called message . Consider these alternative XML syntaxes: <SaySomething name= \"first\" message= \"hello world\" /> <SaySomething name= \"second\" message= \"{greetings}\" /> The attribute message in the first node means: \"The static string 'hello world' is passed to the port 'message' of 'SaySomething'\". The message is read from the XML file, therefore it can not change at run-time. The syntax of the second node instead means: \"Read the current value in the entry of the blackboard called 'greetings' \". This value can (and probably will) change at run-time. The ActionNode SaySomething can be implemented as follows: // SyncActionNode (synchronous action) with an input port. class SaySomething : public SyncActionNode { public : // If your Node has ports, you must use this constructor signature SaySomething ( const std :: string & name , const NodeConfiguration & config ) : SyncActionNode ( name , config ) { } // It is mandatory to define this static method. static PortsList providedPorts () { // This action has a single input port called \"message\" // Any port must have a name. The type is optional. return { InputPort < std :: string > ( \"message\" ) }; } // As usual, you must override the virtual function tick() NodeStatus tick () override { Optional < std :: string > msg = getInput < std :: string > ( \"message\" ); // Check if optional is valid. If not, throw its error if ( ! msg ) { throw BT :: RuntimeError ( \"missing required input [message]: \" , msg . error () ); } // use the method value() to extract the valid message. std :: cout << \"Robot says: \" << msg . value () << std :: endl ; return NodeStatus :: SUCCESS ; } }; Alternatively the same functionality can be implemented in a simple function. This function takes an instance of BT:TreeNode as input in order to access the \"message\" Input Port: // Simple function that return a NodeStatus BT :: NodeStatus SaySomethingSimple ( BT :: TreeNode & self ) { Optional < std :: string > msg = self . getInput < std :: string > ( \"message\" ); // Check if optional is valid. If not, throw its error if ( ! msg ) { throw BT :: RuntimeError ( \"missing required input [message]: \" , msg . error ()); } // use the method value() to extract the valid message. std :: cout << \"Robot says: \" << msg . value () << std :: endl ; return NodeStatus :: SUCCESS ; } When a custom TreeNode has input and/or output ports, these ports must be declared in the static method: static MyCustomNode :: PortsList providedPorts (); The input from the port message can be read using the template method TreeNode::getInput<T>(key) . This method may fail for multiple reasons. It is up to the user to check the validity of the returned value and to decide what to do: Return NodeStatus::FAILURE ? Throw an exception? Use a different default value? Important It is always recommended to call the method getInput() inside the tick() , and not in the constructor of the class. The C++ code must not make any assumption about the nature of the input, which could be either static or dynamic. A dynamic input can change at run-time, for this reason it should be read periodically. Output ports An input port pointing to the entry of the blackboard will be valid only if another node have already written \"something\" inside that same entry. ThinkWhatToSay is an example of Node that uses an output port to write a string into an entry. class ThinkWhatToSay : public SyncActionNode { public : ThinkWhatToSay ( const std :: string & name , const NodeConfiguration & config ) : SyncActionNode ( name , config ) { } static PortsList providedPorts () { return { OutputPort < std :: string > ( \"text\" ) }; } // This Action writes a value into the port \"text\" NodeStatus tick () override { // the output may change at each tick(). Here we keep it simple. setOutput ( \"text\" , \"The answer is 42\" ); return NodeStatus :: SUCCESS ; } }; Alternatively, most of the time for debugging purposes, it is possible to write a static value into an entry using the built-in Actions called SetBlackboard . <SetBlackboard output_key= \"the_answer\" value= \"The answer is 42\" /> A complete example In this example, a Sequence of 5 Actions is executed: Actions 1 and 4 read the input message from a static string. Actions 3 and 5 read the input message from an entry in the blackboard called the_answer . Action 2 writes something into the entry of the blackboard called the_answer . SaySomething2 is a SimpleActionNode. <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence name= \"root_sequence\" > <SaySomething message= \"start thinking...\" /> <ThinkWhatToSay text= \"{the_answer}\" /> <SaySomething message= \"{the_answer}\" /> <SaySomething2 message= \"SaySomething2 works too...\" /> <SaySomething2 message= \"{the_answer}\" /> </Sequence> </BehaviorTree> </root> The C++ code: #include \"behaviortree_cpp_v3/bt_factory.h\" // file that contains the custom nodes definitions #include \"dummy_nodes.h\" int main () { using namespace DummyNodes ; BehaviorTreeFactory factory ; factory . registerNodeType < SaySomething > ( \"SaySomething\" ); factory . registerNodeType < ThinkWhatToSay > ( \"ThinkWhatToSay\" ); // SimpleActionNodes can not define their own method providedPorts(). // We should pass a PortsList explicitly if we want the Action to // be able to use getInput() or setOutput(); PortsList say_something_ports = { InputPort < std :: string > ( \"message\" ) }; factory . registerSimpleAction ( \"SaySomething2\" , SaySomethingSimple , say_something_ports ); auto tree = factory . createTreeFromFile ( \"./my_tree.xml\" ); tree . tickRoot (); /* Expected output: Robot says: start thinking... Robot says: The answer is 42 Robot says: SaySomething2 works too... Robot says: The answer is 42 */ return 0 ; } We \"connect\" output ports to input ports using the same key ( the_answer ); this means that they \"point\" to the same entry of the blackboard. These ports can be connected to each other because their type is the same, i.e. std::string .","title":"Tutorial 2: Basic Ports"},{"location":"tutorial_02_basic_ports/#input-and-output-ports","text":"As we explained earlier, custom TreeNodes can be used to execute an arbitrarily simple or complex piece of software. Their goal is to provide an interface with a higher level of abstraction . For this reason, they are not conceptually different from functions . Similar to functions, we often want to: pass arguments/parameters to a Node ( inputs ) get some kind of information out from a Node ( outputs ). The outputs of a node can be the inputs of another node. BehaviorTree.CPP provides a basic mechanism of dataflow through ports , that is simple to use but also flexible and type safe.","title":"Input and Output Ports"},{"location":"tutorial_02_basic_ports/#inputs-ports","text":"A valid Input can be either: static strings which can be parsed by the Node, or \"pointers\" to an entry of the Blackboard, identified by a key . A \"blackboard\" is a simple key/value storage shared by all the nodes of the Tree. An \"entry\" of the Blackboard is a key/value pair . Input ports can read an entry in the Blackboard, whilst an Output port can write into an entry. Let's suppose that we want to create an ActionNode called SaySomething , that should print a given string on std::cout . Such a string will be passed using an input port called message . Consider these alternative XML syntaxes: <SaySomething name= \"first\" message= \"hello world\" /> <SaySomething name= \"second\" message= \"{greetings}\" /> The attribute message in the first node means: \"The static string 'hello world' is passed to the port 'message' of 'SaySomething'\". The message is read from the XML file, therefore it can not change at run-time. The syntax of the second node instead means: \"Read the current value in the entry of the blackboard called 'greetings' \". This value can (and probably will) change at run-time. The ActionNode SaySomething can be implemented as follows: // SyncActionNode (synchronous action) with an input port. class SaySomething : public SyncActionNode { public : // If your Node has ports, you must use this constructor signature SaySomething ( const std :: string & name , const NodeConfiguration & config ) : SyncActionNode ( name , config ) { } // It is mandatory to define this static method. static PortsList providedPorts () { // This action has a single input port called \"message\" // Any port must have a name. The type is optional. return { InputPort < std :: string > ( \"message\" ) }; } // As usual, you must override the virtual function tick() NodeStatus tick () override { Optional < std :: string > msg = getInput < std :: string > ( \"message\" ); // Check if optional is valid. If not, throw its error if ( ! msg ) { throw BT :: RuntimeError ( \"missing required input [message]: \" , msg . error () ); } // use the method value() to extract the valid message. std :: cout << \"Robot says: \" << msg . value () << std :: endl ; return NodeStatus :: SUCCESS ; } }; Alternatively the same functionality can be implemented in a simple function. This function takes an instance of BT:TreeNode as input in order to access the \"message\" Input Port: // Simple function that return a NodeStatus BT :: NodeStatus SaySomethingSimple ( BT :: TreeNode & self ) { Optional < std :: string > msg = self . getInput < std :: string > ( \"message\" ); // Check if optional is valid. If not, throw its error if ( ! msg ) { throw BT :: RuntimeError ( \"missing required input [message]: \" , msg . error ()); } // use the method value() to extract the valid message. std :: cout << \"Robot says: \" << msg . value () << std :: endl ; return NodeStatus :: SUCCESS ; } When a custom TreeNode has input and/or output ports, these ports must be declared in the static method: static MyCustomNode :: PortsList providedPorts (); The input from the port message can be read using the template method TreeNode::getInput<T>(key) . This method may fail for multiple reasons. It is up to the user to check the validity of the returned value and to decide what to do: Return NodeStatus::FAILURE ? Throw an exception? Use a different default value? Important It is always recommended to call the method getInput() inside the tick() , and not in the constructor of the class. The C++ code must not make any assumption about the nature of the input, which could be either static or dynamic. A dynamic input can change at run-time, for this reason it should be read periodically.","title":"Inputs ports"},{"location":"tutorial_02_basic_ports/#output-ports","text":"An input port pointing to the entry of the blackboard will be valid only if another node have already written \"something\" inside that same entry. ThinkWhatToSay is an example of Node that uses an output port to write a string into an entry. class ThinkWhatToSay : public SyncActionNode { public : ThinkWhatToSay ( const std :: string & name , const NodeConfiguration & config ) : SyncActionNode ( name , config ) { } static PortsList providedPorts () { return { OutputPort < std :: string > ( \"text\" ) }; } // This Action writes a value into the port \"text\" NodeStatus tick () override { // the output may change at each tick(). Here we keep it simple. setOutput ( \"text\" , \"The answer is 42\" ); return NodeStatus :: SUCCESS ; } }; Alternatively, most of the time for debugging purposes, it is possible to write a static value into an entry using the built-in Actions called SetBlackboard . <SetBlackboard output_key= \"the_answer\" value= \"The answer is 42\" />","title":"Output ports"},{"location":"tutorial_02_basic_ports/#a-complete-example","text":"In this example, a Sequence of 5 Actions is executed: Actions 1 and 4 read the input message from a static string. Actions 3 and 5 read the input message from an entry in the blackboard called the_answer . Action 2 writes something into the entry of the blackboard called the_answer . SaySomething2 is a SimpleActionNode. <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence name= \"root_sequence\" > <SaySomething message= \"start thinking...\" /> <ThinkWhatToSay text= \"{the_answer}\" /> <SaySomething message= \"{the_answer}\" /> <SaySomething2 message= \"SaySomething2 works too...\" /> <SaySomething2 message= \"{the_answer}\" /> </Sequence> </BehaviorTree> </root> The C++ code: #include \"behaviortree_cpp_v3/bt_factory.h\" // file that contains the custom nodes definitions #include \"dummy_nodes.h\" int main () { using namespace DummyNodes ; BehaviorTreeFactory factory ; factory . registerNodeType < SaySomething > ( \"SaySomething\" ); factory . registerNodeType < ThinkWhatToSay > ( \"ThinkWhatToSay\" ); // SimpleActionNodes can not define their own method providedPorts(). // We should pass a PortsList explicitly if we want the Action to // be able to use getInput() or setOutput(); PortsList say_something_ports = { InputPort < std :: string > ( \"message\" ) }; factory . registerSimpleAction ( \"SaySomething2\" , SaySomethingSimple , say_something_ports ); auto tree = factory . createTreeFromFile ( \"./my_tree.xml\" ); tree . tickRoot (); /* Expected output: Robot says: start thinking... Robot says: The answer is 42 Robot says: SaySomething2 works too... Robot says: The answer is 42 */ return 0 ; } We \"connect\" output ports to input ports using the same key ( the_answer ); this means that they \"point\" to the same entry of the blackboard. These ports can be connected to each other because their type is the same, i.e. std::string .","title":"A complete example"},{"location":"tutorial_03_generic_ports/","text":"Ports with generic types In the previous tutorials we introduced input and output ports, where the type of the port itself was a std::string . This is the easiest port type to deal with, because any parameter passed from the XML definition will be (obviously) a string. Next, we will describe how to use any generic C++ type in your code. Parsing a string BehaviorTree.CPP supports automatic conversion of strings into common types, such as int , long , double , bool , NodeStatus , etc. But user defined types can be supported easily as well. For instance: // We want to be able to use this custom type struct Position2D { double x ; double y ; }; To parse a string into a Position2D we should link to a template specialization of BT::convertFromString<Position2D>(StringView) . We can use any syntax we want; in this case, we simply separate two numbers with a semicolon . // Template specialization to converts a string to Position2D. namespace BT { template <> inline Position2D convertFromString ( StringView str ) { // The next line should be removed... printf ( \"Converting string: \\\" %s \\\"\\n \" , str . data () ); // We expect real numbers separated by semicolons auto parts = splitString ( str , ';' ); if ( parts . size () != 2 ) { throw RuntimeError ( \"invalid input)\" ); } else { Position2D output ; output . x = convertFromString < double > ( parts [ 0 ]); output . y = convertFromString < double > ( parts [ 1 ]); return output ; } } } // end namespace BT About the previous code: StringView is just a C++11 version of std::string_view . You can pass either a std::string or a const char* . In production code, you would (obviously) remove the printf statement. The library provides a simple splitString function. Feel free to use another one, like boost::algorithm::split . Once we split the input into single numbers, we can reuse the specialization convertFromString<double>() . Example Similarly to the previous tutorial, we can create two custom Actions, one will write into a port and the other will read from a port. class CalculateGoal : public SyncActionNode { public : CalculateGoal ( const std :: string & name , const NodeConfiguration & config ) : SyncActionNode ( name , config ) {} static PortsList providedPorts () { return { OutputPort < Position2D > ( \"goal\" ) }; } NodeStatus tick () override { Position2D mygoal = { 1.1 , 2.3 }; setOutput < Position2D > ( \"goal\" , mygoal ); return NodeStatus :: SUCCESS ; } }; class PrintTarget : public SyncActionNode { public : PrintTarget ( const std :: string & name , const NodeConfiguration & config ) : SyncActionNode ( name , config ) {} static PortsList providedPorts () { // Optionally, a port can have a human readable description const char * description = \"Simply print the goal on console...\" ; return { InputPort < Position2D > ( \"target\" , description ) }; } NodeStatus tick () override { auto res = getInput < Position2D > ( \"target\" ); if ( ! res ) { throw RuntimeError ( \"error reading port [target]:\" , res . error ()); } Position2D target = res . value (); printf ( \"Target positions: [ %.1f, %.1f ] \\n \" , target . x , target . y ); return NodeStatus :: SUCCESS ; } }; We can now connect input/output ports as usual, pointing to the same entry of the Blackboard. The tree in the next example is a Sequence of 4 actions Store a value of Position2D in the entry \"GoalPosition\", using the action CalculateGoal . Call PrintTarget . The input \"target\" will be read from the Blackboard entry \"GoalPosition\". Use the built-in action SetBlackboard to write the key \"OtherGoal\". A conversion from string to Position2D will be done under the hood. Call PrintTarget again. The input \"target\" will be read from the Blackboard entry \"OtherGoal\". static const char * xml_text = R \" ( <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID=\"MainTree\"> <SequenceStar name=\"root\"> <CalculateGoal goal=\"{GoalPosition}\" /> <PrintTarget target=\"{GoalPosition}\" /> <SetBlackboard output_key=\"OtherGoal\" value=\"-1;3\" /> <PrintTarget target=\"{OtherGoal}\" /> </SequenceStar> </BehaviorTree> </root> ) \" ; int main () { using namespace BT ; BehaviorTreeFactory factory ; factory . registerNodeType < CalculateGoal > ( \"CalculateGoal\" ); factory . registerNodeType < PrintTarget > ( \"PrintTarget\" ); auto tree = factory . createTreeFromText ( xml_text ); tree . tickRoot (); /* Expected output: Target positions: [ 1.1, 2.3 ] Converting string: \"-1;3\" Target positions: [ -1.0, 3.0 ] */ return 0 ; }","title":"Tutorial 3: Generic ports"},{"location":"tutorial_03_generic_ports/#ports-with-generic-types","text":"In the previous tutorials we introduced input and output ports, where the type of the port itself was a std::string . This is the easiest port type to deal with, because any parameter passed from the XML definition will be (obviously) a string. Next, we will describe how to use any generic C++ type in your code.","title":"Ports with generic types"},{"location":"tutorial_03_generic_ports/#parsing-a-string","text":"BehaviorTree.CPP supports automatic conversion of strings into common types, such as int , long , double , bool , NodeStatus , etc. But user defined types can be supported easily as well. For instance: // We want to be able to use this custom type struct Position2D { double x ; double y ; }; To parse a string into a Position2D we should link to a template specialization of BT::convertFromString<Position2D>(StringView) . We can use any syntax we want; in this case, we simply separate two numbers with a semicolon . // Template specialization to converts a string to Position2D. namespace BT { template <> inline Position2D convertFromString ( StringView str ) { // The next line should be removed... printf ( \"Converting string: \\\" %s \\\"\\n \" , str . data () ); // We expect real numbers separated by semicolons auto parts = splitString ( str , ';' ); if ( parts . size () != 2 ) { throw RuntimeError ( \"invalid input)\" ); } else { Position2D output ; output . x = convertFromString < double > ( parts [ 0 ]); output . y = convertFromString < double > ( parts [ 1 ]); return output ; } } } // end namespace BT About the previous code: StringView is just a C++11 version of std::string_view . You can pass either a std::string or a const char* . In production code, you would (obviously) remove the printf statement. The library provides a simple splitString function. Feel free to use another one, like boost::algorithm::split . Once we split the input into single numbers, we can reuse the specialization convertFromString<double>() .","title":"Parsing a string"},{"location":"tutorial_03_generic_ports/#example","text":"Similarly to the previous tutorial, we can create two custom Actions, one will write into a port and the other will read from a port. class CalculateGoal : public SyncActionNode { public : CalculateGoal ( const std :: string & name , const NodeConfiguration & config ) : SyncActionNode ( name , config ) {} static PortsList providedPorts () { return { OutputPort < Position2D > ( \"goal\" ) }; } NodeStatus tick () override { Position2D mygoal = { 1.1 , 2.3 }; setOutput < Position2D > ( \"goal\" , mygoal ); return NodeStatus :: SUCCESS ; } }; class PrintTarget : public SyncActionNode { public : PrintTarget ( const std :: string & name , const NodeConfiguration & config ) : SyncActionNode ( name , config ) {} static PortsList providedPorts () { // Optionally, a port can have a human readable description const char * description = \"Simply print the goal on console...\" ; return { InputPort < Position2D > ( \"target\" , description ) }; } NodeStatus tick () override { auto res = getInput < Position2D > ( \"target\" ); if ( ! res ) { throw RuntimeError ( \"error reading port [target]:\" , res . error ()); } Position2D target = res . value (); printf ( \"Target positions: [ %.1f, %.1f ] \\n \" , target . x , target . y ); return NodeStatus :: SUCCESS ; } }; We can now connect input/output ports as usual, pointing to the same entry of the Blackboard. The tree in the next example is a Sequence of 4 actions Store a value of Position2D in the entry \"GoalPosition\", using the action CalculateGoal . Call PrintTarget . The input \"target\" will be read from the Blackboard entry \"GoalPosition\". Use the built-in action SetBlackboard to write the key \"OtherGoal\". A conversion from string to Position2D will be done under the hood. Call PrintTarget again. The input \"target\" will be read from the Blackboard entry \"OtherGoal\". static const char * xml_text = R \" ( <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID=\"MainTree\"> <SequenceStar name=\"root\"> <CalculateGoal goal=\"{GoalPosition}\" /> <PrintTarget target=\"{GoalPosition}\" /> <SetBlackboard output_key=\"OtherGoal\" value=\"-1;3\" /> <PrintTarget target=\"{OtherGoal}\" /> </SequenceStar> </BehaviorTree> </root> ) \" ; int main () { using namespace BT ; BehaviorTreeFactory factory ; factory . registerNodeType < CalculateGoal > ( \"CalculateGoal\" ); factory . registerNodeType < PrintTarget > ( \"PrintTarget\" ); auto tree = factory . createTreeFromText ( xml_text ); tree . tickRoot (); /* Expected output: Target positions: [ 1.1, 2.3 ] Converting string: \"-1;3\" Target positions: [ -1.0, 3.0 ] */ return 0 ; }","title":"Example"},{"location":"tutorial_04_sequence/","text":"Sequences and AsyncActionNode The next example shows the difference between a SequenceNode and a ReactiveSequence . An Asynchronous Action has it's own thread. This allows the user to use blocking functions but to return the flow of execution to the tree. // Custom type struct Pose2D { double x , y , theta ; }; class MoveBaseAction : public AsyncActionNode { public : MoveBaseAction ( const std :: string & name , const NodeConfiguration & config ) : AsyncActionNode ( name , config ) { } static PortsList providedPorts () { return { InputPort < Pose2D > ( \"goal\" ) }; } NodeStatus tick () override ; // This overloaded method is used to stop the execution of this node. void halt () override { _halt_requested . store ( true ); } private : std :: atomic_bool _halt_requested ; }; //------------------------- NodeStatus MoveBaseAction::tick () { Pose2D goal ; if ( ! getInput < Pose2D > ( \"goal\" , goal )) { throw RuntimeError ( \"missing required input [goal]\" ); } printf ( \"[ MoveBase: STARTED ]. goal: x=%.f y=%.1f theta=%.2f \\n \" , goal . x , goal . y , goal . theta ); _halt_requested . store ( false ); int count = 0 ; // Pretend that \"computing\" takes 250 milliseconds. // It is up to you to check periodicall _halt_requested and interrupt // this tick() if it is true. while ( ! _halt_requested && count ++ < 25 ) { SleepMS ( 10 ); } std :: cout << \"[ MoveBase: FINISHED ]\" << std :: endl ; return _halt_requested ? NodeStatus :: FAILURE : NodeStatus :: SUCCESS ; } The method MoveBaseAction::tick() is executed in a thread different from the main thread that invoked MoveBaseAction::executeTick() . You are responsible for the implementation of a valid halt() functionality. The user must also implement convertFromString<Pose2D>(StringView) , as shown in the previous tutorial. Sequence VS ReactiveSequence The following example should use a simple SequenceNode . <root> <BehaviorTree> <Sequence> <BatteryOK/> <SaySomething message= \"mission started...\" /> <MoveBase goal= \"1;2;3\" /> <SaySomething message= \"mission completed!\" /> </Sequence> </BehaviorTree> </root> int main () { using namespace DummyNodes ; BehaviorTreeFactory factory ; factory . registerSimpleCondition ( \"BatteryOK\" , std :: bind ( CheckBattery )); factory . registerNodeType < MoveBaseAction > ( \"MoveBase\" ); factory . registerNodeType < SaySomething > ( \"SaySomething\" ); auto tree = factory . createTreeFromText ( xml_text ); NodeStatus status ; std :: cout << \" \\n --- 1st executeTick() ---\" << std :: endl ; status = tree . tickRoot (); SleepMS ( 150 ); std :: cout << \" \\n --- 2nd executeTick() ---\" << std :: endl ; status = tree . tickRoot (); SleepMS ( 150 ); std :: cout << \" \\n --- 3rd executeTick() ---\" << std :: endl ; status = tree . tickRoot (); std :: cout << std :: endl ; return 0 ; } Expected output: --- 1st executeTick() --- [ Battery: OK ] Robot says: \"mission started...\" [ MoveBase: STARTED ]. goal: x=1 y=2.0 theta=3.00 --- 2nd executeTick() --- [ MoveBase: FINISHED ] --- 3rd executeTick() --- Robot says: \"mission completed!\" You may have noticed that when executeTick() was called, MoveBase returned RUNNING the 1st and 2nd time, and eventually SUCCESS the 3rd time. BatteryOK is executed only once. If we use a ReactiveSequence instead, when the child MoveBase returns RUNNING, the sequence is restarted and the condition BatteryOK is executed again . If, at any point, BatteryOK returned FAILURE , the MoveBase action would be interrupted ( halted , to be specific). <root> <BehaviorTree> <ReactiveSequence> <BatteryOK/> <Sequence> <SaySomething message= \"mission started...\" /> <MoveBase goal= \"1;2;3\" /> <SaySomething message= \"mission completed!\" /> </Sequence> </ReactiveSequence> </BehaviorTree> </root> Expected output: --- 1st executeTick() --- [ Battery: OK ] Robot says: \"mission started...\" [ MoveBase: STARTED ]. goal: x=1 y=2.0 theta=3.00 --- 2nd executeTick() --- [ Battery: OK ] [ MoveBase: FINISHED ] --- 3rd executeTick() --- [ Battery: OK ] Robot says: \"mission completed!\"","title":"Tutorial 4: Sequences"},{"location":"tutorial_04_sequence/#sequences-and-asyncactionnode","text":"The next example shows the difference between a SequenceNode and a ReactiveSequence . An Asynchronous Action has it's own thread. This allows the user to use blocking functions but to return the flow of execution to the tree. // Custom type struct Pose2D { double x , y , theta ; }; class MoveBaseAction : public AsyncActionNode { public : MoveBaseAction ( const std :: string & name , const NodeConfiguration & config ) : AsyncActionNode ( name , config ) { } static PortsList providedPorts () { return { InputPort < Pose2D > ( \"goal\" ) }; } NodeStatus tick () override ; // This overloaded method is used to stop the execution of this node. void halt () override { _halt_requested . store ( true ); } private : std :: atomic_bool _halt_requested ; }; //------------------------- NodeStatus MoveBaseAction::tick () { Pose2D goal ; if ( ! getInput < Pose2D > ( \"goal\" , goal )) { throw RuntimeError ( \"missing required input [goal]\" ); } printf ( \"[ MoveBase: STARTED ]. goal: x=%.f y=%.1f theta=%.2f \\n \" , goal . x , goal . y , goal . theta ); _halt_requested . store ( false ); int count = 0 ; // Pretend that \"computing\" takes 250 milliseconds. // It is up to you to check periodicall _halt_requested and interrupt // this tick() if it is true. while ( ! _halt_requested && count ++ < 25 ) { SleepMS ( 10 ); } std :: cout << \"[ MoveBase: FINISHED ]\" << std :: endl ; return _halt_requested ? NodeStatus :: FAILURE : NodeStatus :: SUCCESS ; } The method MoveBaseAction::tick() is executed in a thread different from the main thread that invoked MoveBaseAction::executeTick() . You are responsible for the implementation of a valid halt() functionality. The user must also implement convertFromString<Pose2D>(StringView) , as shown in the previous tutorial.","title":"Sequences and AsyncActionNode"},{"location":"tutorial_04_sequence/#sequence-vs-reactivesequence","text":"The following example should use a simple SequenceNode . <root> <BehaviorTree> <Sequence> <BatteryOK/> <SaySomething message= \"mission started...\" /> <MoveBase goal= \"1;2;3\" /> <SaySomething message= \"mission completed!\" /> </Sequence> </BehaviorTree> </root> int main () { using namespace DummyNodes ; BehaviorTreeFactory factory ; factory . registerSimpleCondition ( \"BatteryOK\" , std :: bind ( CheckBattery )); factory . registerNodeType < MoveBaseAction > ( \"MoveBase\" ); factory . registerNodeType < SaySomething > ( \"SaySomething\" ); auto tree = factory . createTreeFromText ( xml_text ); NodeStatus status ; std :: cout << \" \\n --- 1st executeTick() ---\" << std :: endl ; status = tree . tickRoot (); SleepMS ( 150 ); std :: cout << \" \\n --- 2nd executeTick() ---\" << std :: endl ; status = tree . tickRoot (); SleepMS ( 150 ); std :: cout << \" \\n --- 3rd executeTick() ---\" << std :: endl ; status = tree . tickRoot (); std :: cout << std :: endl ; return 0 ; } Expected output: --- 1st executeTick() --- [ Battery: OK ] Robot says: \"mission started...\" [ MoveBase: STARTED ]. goal: x=1 y=2.0 theta=3.00 --- 2nd executeTick() --- [ MoveBase: FINISHED ] --- 3rd executeTick() --- Robot says: \"mission completed!\" You may have noticed that when executeTick() was called, MoveBase returned RUNNING the 1st and 2nd time, and eventually SUCCESS the 3rd time. BatteryOK is executed only once. If we use a ReactiveSequence instead, when the child MoveBase returns RUNNING, the sequence is restarted and the condition BatteryOK is executed again . If, at any point, BatteryOK returned FAILURE , the MoveBase action would be interrupted ( halted , to be specific). <root> <BehaviorTree> <ReactiveSequence> <BatteryOK/> <Sequence> <SaySomething message= \"mission started...\" /> <MoveBase goal= \"1;2;3\" /> <SaySomething message= \"mission completed!\" /> </Sequence> </ReactiveSequence> </BehaviorTree> </root> Expected output: --- 1st executeTick() --- [ Battery: OK ] Robot says: \"mission started...\" [ MoveBase: STARTED ]. goal: x=1 y=2.0 theta=3.00 --- 2nd executeTick() --- [ Battery: OK ] [ MoveBase: FINISHED ] --- 3rd executeTick() --- [ Battery: OK ] Robot says: \"mission completed!\"","title":"Sequence VS ReactiveSequence"},{"location":"tutorial_05_subtrees/","text":"Composition of Behaviors with Subtree We can build large scale behavior composing together smaller and reusable behaviors into larger ones. In other words, we want to create hierarchical behavior trees. This can be achieved easily defining multiple trees in the XML including one into the other. CrossDoor behavior This example is inspired by a popular article about behavior trees . It is also the first practical example that uses Decorators and Fallback . <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"DoorClosed\" > <Sequence name= \"door_closed_sequence\" > <Inverter> <IsDoorOpen/> </Inverter> <RetryUntilSuccessful num_attempts= \"4\" > <OpenDoor/> </RetryUntilSuccessful> <PassThroughDoor/> </Sequence> </BehaviorTree> <BehaviorTree ID= \"MainTree\" > <Fallback name= \"root_Fallback\" > <Sequence name= \"door_open_sequence\" > <IsDoorOpen/> <PassThroughDoor/> </Sequence> <SubTree ID= \"DoorClosed\" /> <PassThroughWindow/> </Fallback> </BehaviorTree> </root> It may be noticed that we incapsulated a quite complex branch of the tree, the one to execute when the door is closed, into a separate tree called DoorClosed . The desired behavior is: If the door is open, PassThroughDoor . If the door is closed, try up to 4 times to OpenDoor and, then, PassThroughDoor . If it was not possible to open the closed door, PassThroughWindow . Loggers On the C++ side we don't need to do anything to build reusable subtrees. Therefore we take this opportunity to introduce another neat feature of BehaviorTree.CPP : Loggers . A Logger is a mechanism to display, record and/or publish any state change in the tree. int main () { using namespace BT ; BehaviorTreeFactory factory ; // register all the actions into the factory // We don't show how these actions are implemented, since most of the // times they just print a message on screen and return SUCCESS. // See the code on Github for more details. factory . registerSimpleCondition ( \"IsDoorOpen\" , std :: bind ( IsDoorOpen )); factory . registerSimpleAction ( \"PassThroughDoor\" , std :: bind ( PassThroughDoor )); factory . registerSimpleAction ( \"PassThroughWindow\" , std :: bind ( PassThroughWindow )); factory . registerSimpleAction ( \"OpenDoor\" , std :: bind ( OpenDoor )); factory . registerSimpleAction ( \"CloseDoor\" , std :: bind ( CloseDoor )); factory . registerSimpleCondition ( \"IsDoorLocked\" , std :: bind ( IsDoorLocked )); factory . registerSimpleAction ( \"UnlockDoor\" , std :: bind ( UnlockDoor )); // Load from text or file... auto tree = factory . createTreeFromText ( xml_text ); // This logger prints state changes on console StdCoutLogger logger_cout ( tree ); // This logger saves state changes on file FileLogger logger_file ( tree , \"bt_trace.fbl\" ); // This logger stores the execution time of each node MinitraceLogger logger_minitrace ( tree , \"bt_trace.json\" ); #ifdef ZMQ_FOUND // This logger publish status changes using ZeroMQ. Used by Groot PublisherZMQ publisher_zmq ( tree ); #endif printTreeRecursively ( tree . rootNode ()); //while (1) { NodeStatus status = NodeStatus :: RUNNING ; // Keep on ticking until you get either a SUCCESS or FAILURE state while ( status == NodeStatus :: RUNNING ) { status = tree . tickRoot (); CrossDoor :: SleepMS ( 1 ); // optional sleep to avoid \"busy loops\" } CrossDoor :: SleepMS ( 2000 ); } return 0 ; }","title":"Tutorial 5: Subtrees and Loggers"},{"location":"tutorial_05_subtrees/#composition-of-behaviors-with-subtree","text":"We can build large scale behavior composing together smaller and reusable behaviors into larger ones. In other words, we want to create hierarchical behavior trees. This can be achieved easily defining multiple trees in the XML including one into the other.","title":"Composition of Behaviors with Subtree"},{"location":"tutorial_05_subtrees/#crossdoor-behavior","text":"This example is inspired by a popular article about behavior trees . It is also the first practical example that uses Decorators and Fallback . <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"DoorClosed\" > <Sequence name= \"door_closed_sequence\" > <Inverter> <IsDoorOpen/> </Inverter> <RetryUntilSuccessful num_attempts= \"4\" > <OpenDoor/> </RetryUntilSuccessful> <PassThroughDoor/> </Sequence> </BehaviorTree> <BehaviorTree ID= \"MainTree\" > <Fallback name= \"root_Fallback\" > <Sequence name= \"door_open_sequence\" > <IsDoorOpen/> <PassThroughDoor/> </Sequence> <SubTree ID= \"DoorClosed\" /> <PassThroughWindow/> </Fallback> </BehaviorTree> </root> It may be noticed that we incapsulated a quite complex branch of the tree, the one to execute when the door is closed, into a separate tree called DoorClosed . The desired behavior is: If the door is open, PassThroughDoor . If the door is closed, try up to 4 times to OpenDoor and, then, PassThroughDoor . If it was not possible to open the closed door, PassThroughWindow .","title":"CrossDoor behavior"},{"location":"tutorial_05_subtrees/#loggers","text":"On the C++ side we don't need to do anything to build reusable subtrees. Therefore we take this opportunity to introduce another neat feature of BehaviorTree.CPP : Loggers . A Logger is a mechanism to display, record and/or publish any state change in the tree. int main () { using namespace BT ; BehaviorTreeFactory factory ; // register all the actions into the factory // We don't show how these actions are implemented, since most of the // times they just print a message on screen and return SUCCESS. // See the code on Github for more details. factory . registerSimpleCondition ( \"IsDoorOpen\" , std :: bind ( IsDoorOpen )); factory . registerSimpleAction ( \"PassThroughDoor\" , std :: bind ( PassThroughDoor )); factory . registerSimpleAction ( \"PassThroughWindow\" , std :: bind ( PassThroughWindow )); factory . registerSimpleAction ( \"OpenDoor\" , std :: bind ( OpenDoor )); factory . registerSimpleAction ( \"CloseDoor\" , std :: bind ( CloseDoor )); factory . registerSimpleCondition ( \"IsDoorLocked\" , std :: bind ( IsDoorLocked )); factory . registerSimpleAction ( \"UnlockDoor\" , std :: bind ( UnlockDoor )); // Load from text or file... auto tree = factory . createTreeFromText ( xml_text ); // This logger prints state changes on console StdCoutLogger logger_cout ( tree ); // This logger saves state changes on file FileLogger logger_file ( tree , \"bt_trace.fbl\" ); // This logger stores the execution time of each node MinitraceLogger logger_minitrace ( tree , \"bt_trace.json\" ); #ifdef ZMQ_FOUND // This logger publish status changes using ZeroMQ. Used by Groot PublisherZMQ publisher_zmq ( tree ); #endif printTreeRecursively ( tree . rootNode ()); //while (1) { NodeStatus status = NodeStatus :: RUNNING ; // Keep on ticking until you get either a SUCCESS or FAILURE state while ( status == NodeStatus :: RUNNING ) { status = tree . tickRoot (); CrossDoor :: SleepMS ( 1 ); // optional sleep to avoid \"busy loops\" } CrossDoor :: SleepMS ( 2000 ); } return 0 ; }","title":"Loggers"},{"location":"tutorial_06_subtree_ports/","text":"Remapping ports between Trees and SubTrees In the CrossDoor example we saw that a SubTree looks like a single leaf Node from the point of view of its parent ( MainTree in the example). Furthermore, to avoid name clashing in very large trees, any tree and subtree use a different instance of the Blackboard. For this reason, we need to explicitly connect the ports of a tree to those of its subtrees. Once again, you won't need to modify your C++ implementation since this remapping is done entirely in the XML definition. Example Let's consider this Beahavior Tree. <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence name= \"main_sequence\" > <SetBlackboard output_key= \"move_goal\" value= \"1;2;3\" /> <SubTree ID= \"MoveRobot\" target= \"move_goal\" output= \"move_result\" /> <SaySomething message= \"{move_result}\" /> </Sequence> </BehaviorTree> <BehaviorTree ID= \"MoveRobot\" > <Fallback name= \"move_robot_main\" > <SequenceStar> <MoveBase goal= \"{target}\" /> <SetBlackboard output_key= \"output\" value= \"mission accomplished\" /> </SequenceStar> <ForceFailure> <SetBlackboard output_key= \"output\" value= \"mission failed\" /> </ForceFailure> </Fallback> </BehaviorTree> </root> You may notice that: We have a MainTree that includes a subtree called MoveRobot . We want to \"connect\" (i.e. \"remap\") ports inside the MoveRobot subtree with other ports in the MainTree . This is done using the XMl tag , where the words internal/external refer respectively to a subtree and its parent. The following image shows remapping between these two different trees. Note that this diagram represents the dataflow and the entries in the respective blackboard, not the relationship in terms of Behavior Trees. In terms of C++, we don't need to do much. For debugging purpose, we may show some information about the current state of a blackboard with the method debugMessage() . int main () { BT :: BehaviorTreeFactory factory ; factory . registerNodeType < SaySomething > ( \"SaySomething\" ); factory . registerNodeType < MoveBaseAction > ( \"MoveBase\" ); auto tree = factory . createTreeFromText ( xml_text ); NodeStatus status = NodeStatus :: RUNNING ; // Keep on ticking until you get either a SUCCESS or FAILURE state while ( status == NodeStatus :: RUNNING ) { status = tree . tickRoot (); SleepMS ( 1 ); // optional sleep to avoid \"busy loops\" } // let's visualize some information about the current state of the blackboards. std :: cout << \"--------------\" << std :: endl ; tree . blackboard_stack [ 0 ] -> debugMessage (); std :: cout << \"--------------\" << std :: endl ; tree . blackboard_stack [ 1 ] -> debugMessage (); std :: cout << \"--------------\" << std :: endl ; return 0 ; } /* Expected output: [ MoveBase: STARTED ]. goal: x=1 y=2.0 theta=3.00 [ MoveBase: FINISHED ] Robot says: mission accomplished -------------- move_result (std::string) -> full move_goal (Pose2D) -> full -------------- output (std::string) -> remapped to parent [move_result] target (Pose2D) -> remapped to parent [move_goal] -------------- */","title":"Tutorial 6: Ports remapping"},{"location":"tutorial_06_subtree_ports/#remapping-ports-between-trees-and-subtrees","text":"In the CrossDoor example we saw that a SubTree looks like a single leaf Node from the point of view of its parent ( MainTree in the example). Furthermore, to avoid name clashing in very large trees, any tree and subtree use a different instance of the Blackboard. For this reason, we need to explicitly connect the ports of a tree to those of its subtrees. Once again, you won't need to modify your C++ implementation since this remapping is done entirely in the XML definition.","title":"Remapping ports between Trees and SubTrees"},{"location":"tutorial_06_subtree_ports/#example","text":"Let's consider this Beahavior Tree. <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence name= \"main_sequence\" > <SetBlackboard output_key= \"move_goal\" value= \"1;2;3\" /> <SubTree ID= \"MoveRobot\" target= \"move_goal\" output= \"move_result\" /> <SaySomething message= \"{move_result}\" /> </Sequence> </BehaviorTree> <BehaviorTree ID= \"MoveRobot\" > <Fallback name= \"move_robot_main\" > <SequenceStar> <MoveBase goal= \"{target}\" /> <SetBlackboard output_key= \"output\" value= \"mission accomplished\" /> </SequenceStar> <ForceFailure> <SetBlackboard output_key= \"output\" value= \"mission failed\" /> </ForceFailure> </Fallback> </BehaviorTree> </root> You may notice that: We have a MainTree that includes a subtree called MoveRobot . We want to \"connect\" (i.e. \"remap\") ports inside the MoveRobot subtree with other ports in the MainTree . This is done using the XMl tag , where the words internal/external refer respectively to a subtree and its parent. The following image shows remapping between these two different trees. Note that this diagram represents the dataflow and the entries in the respective blackboard, not the relationship in terms of Behavior Trees. In terms of C++, we don't need to do much. For debugging purpose, we may show some information about the current state of a blackboard with the method debugMessage() . int main () { BT :: BehaviorTreeFactory factory ; factory . registerNodeType < SaySomething > ( \"SaySomething\" ); factory . registerNodeType < MoveBaseAction > ( \"MoveBase\" ); auto tree = factory . createTreeFromText ( xml_text ); NodeStatus status = NodeStatus :: RUNNING ; // Keep on ticking until you get either a SUCCESS or FAILURE state while ( status == NodeStatus :: RUNNING ) { status = tree . tickRoot (); SleepMS ( 1 ); // optional sleep to avoid \"busy loops\" } // let's visualize some information about the current state of the blackboards. std :: cout << \"--------------\" << std :: endl ; tree . blackboard_stack [ 0 ] -> debugMessage (); std :: cout << \"--------------\" << std :: endl ; tree . blackboard_stack [ 1 ] -> debugMessage (); std :: cout << \"--------------\" << std :: endl ; return 0 ; } /* Expected output: [ MoveBase: STARTED ]. goal: x=1 y=2.0 theta=3.00 [ MoveBase: FINISHED ] Robot says: mission accomplished -------------- move_result (std::string) -> full move_goal (Pose2D) -> full -------------- output (std::string) -> remapped to parent [move_result] target (Pose2D) -> remapped to parent [move_goal] -------------- */","title":"Example"},{"location":"tutorial_07_legacy/","text":"Wraping legacy code In this tutorial we will see how to deal with legacy code that was not meant to be used with BehaviorTree.CPP. Your class might look like this one: // This is my custom type. struct Point3D { double x , y , z ; }; // We want to create an ActionNode to calls method MyLegacyMoveTo::go class MyLegacyMoveTo { public : bool go ( Point3D goal ) { printf ( \"Going to: %f %f %f \\n \" , goal . x , goal . y , goal . z ); return true ; // true means success in my legacy code } }; C++ code As usuall, we need to implement the template specialization of convertFromString . namespace BT { template <> Point3D convertFromString ( StringView key ) { // three real numbers separated by semicolons auto parts = BT :: splitString ( key , ';' ); if ( parts . size () != 3 ) { throw RuntimeError ( \"invalid input)\" ); } else { Point3D output ; output . x = convertFromString < double > ( parts [ 0 ]); output . y = convertFromString < double > ( parts [ 1 ]); output . z = convertFromString < double > ( parts [ 2 ]); return output ; } } } // end anmespace BT To wrap the method MyLegacyMoveTo::go , we may use a lambda or std::bind to create a funtion pointer and SimpleActionNode . static const char * xml_text = R \" ( <root> <BehaviorTree> <MoveTo goal=\"-1;3;0.5\" /> </BehaviorTree> </root> ) \" ; int main () { using namespace BT ; MyLegacyMoveTo move_to ; // Here we use a lambda that captures the reference of move_to auto MoveToWrapperWithLambda = [ & move_to ]( TreeNode & parent_node ) -> NodeStatus { Point3D goal ; // thanks to paren_node, you can access easily the input and output ports. parent_node . getInput ( \"goal\" , goal ); bool res = move_to . go ( goal ); // convert bool to NodeStatus return res ? NodeStatus :: SUCCESS : NodeStatus :: FAILURE ; }; BehaviorTreeFactory factory ; // Register the lambda with BehaviorTreeFactory::registerSimpleAction PortsList ports = { BT :: InputPort < Point3D > ( \"goal\" ) }; factory . registerSimpleAction ( \"MoveTo\" , MoveToWrapperWithLambda , ports ); auto tree = factory . createTreeFromText ( xml_text ); tree . tickRoot (); return 0 ; } /* Expected output: Going to: -1.000000 3.000000 0.500000 */","title":"Tutorial 7: Wrap legacy code"},{"location":"tutorial_07_legacy/#wraping-legacy-code","text":"In this tutorial we will see how to deal with legacy code that was not meant to be used with BehaviorTree.CPP. Your class might look like this one: // This is my custom type. struct Point3D { double x , y , z ; }; // We want to create an ActionNode to calls method MyLegacyMoveTo::go class MyLegacyMoveTo { public : bool go ( Point3D goal ) { printf ( \"Going to: %f %f %f \\n \" , goal . x , goal . y , goal . z ); return true ; // true means success in my legacy code } };","title":"Wraping legacy code"},{"location":"tutorial_07_legacy/#c-code","text":"As usuall, we need to implement the template specialization of convertFromString . namespace BT { template <> Point3D convertFromString ( StringView key ) { // three real numbers separated by semicolons auto parts = BT :: splitString ( key , ';' ); if ( parts . size () != 3 ) { throw RuntimeError ( \"invalid input)\" ); } else { Point3D output ; output . x = convertFromString < double > ( parts [ 0 ]); output . y = convertFromString < double > ( parts [ 1 ]); output . z = convertFromString < double > ( parts [ 2 ]); return output ; } } } // end anmespace BT To wrap the method MyLegacyMoveTo::go , we may use a lambda or std::bind to create a funtion pointer and SimpleActionNode . static const char * xml_text = R \" ( <root> <BehaviorTree> <MoveTo goal=\"-1;3;0.5\" /> </BehaviorTree> </root> ) \" ; int main () { using namespace BT ; MyLegacyMoveTo move_to ; // Here we use a lambda that captures the reference of move_to auto MoveToWrapperWithLambda = [ & move_to ]( TreeNode & parent_node ) -> NodeStatus { Point3D goal ; // thanks to paren_node, you can access easily the input and output ports. parent_node . getInput ( \"goal\" , goal ); bool res = move_to . go ( goal ); // convert bool to NodeStatus return res ? NodeStatus :: SUCCESS : NodeStatus :: FAILURE ; }; BehaviorTreeFactory factory ; // Register the lambda with BehaviorTreeFactory::registerSimpleAction PortsList ports = { BT :: InputPort < Point3D > ( \"goal\" ) }; factory . registerSimpleAction ( \"MoveTo\" , MoveToWrapperWithLambda , ports ); auto tree = factory . createTreeFromText ( xml_text ); tree . tickRoot (); return 0 ; } /* Expected output: Going to: -1.000000 3.000000 0.500000 */","title":"C++ code"},{"location":"tutorial_08_additional_args/","text":"Pass additional arguments during initialization and/or construction In every single example we explored so far we were \"forced\" to provide a constructor with the following signature MyCustomNode ( const std :: string & name , const NodeConfiguration & config ); In same cases, it is desirable to pass to the constructor of our class additional arguments, parameters, pointers, references, etc. Many people use blackboards to do that: this is not recomendable. We will just use the word \"arguments\" for the rest of the tutorial. Even if, theoretically, these arguments could be passed using Input Ports, that would be the wrong way to do it if: The arguments are known at deployment-time . The arguments don't change at run-time . The arguments don't need to be set from the XML . If all these conditions are met, using ports or the blackboard is cumbersome and highly discouraged. Method 1: register a custom builder Consider the following custom node called Action_A . We want to pass three additional arguments; they can be arbitrarily complex objects, you are not limited to built-in types. // Action_A has a different constructor than the default one. class Action_A : public SyncActionNode { public : // additional arguments passed to the constructor Action_A ( const std :: string & name , const NodeConfiguration & config , int arg1 , double arg2 , std :: string arg3 ) : SyncActionNode ( name , config ), _arg1 ( arg1 ), _arg2 ( arg2 ), _arg3 ( arg3 ) {} // this example doesn't require any port static PortsList providedPorts () { return {}; } // tick() can access the private members NodeStatus tick () override ; private : int _arg1 ; double _arg2 ; std :: string _arg3 ; }; This node should be registered as shown further: BehaviorTreeFactory factory ; // A node builder is a functor that creates a std::unique_ptr<TreeNode>. // Using lambdas or std::bind, we can easily \"inject\" additional arguments. NodeBuilder builder_A = []( const std :: string & name , const NodeConfiguration & config ) { return std :: make_unique < Action_A > ( name , config , 42 , 3.14 , \"hello world\" ); }; // BehaviorTreeFactory::registerBuilder is a more general way to // register a custom node. factory . registerBuilder < Action_A > ( \"Action_A\" , builder_A ); // Register more custom nodes, if needed. // .... // The rest of your code, where you create and tick the tree, goes here. // .... Method 2: use an init method Alternatively, you may call an init method before ticking the tree. class Action_B : public SyncActionNode { public : // The constructor looks as usual. Action_B ( const std :: string & name , const NodeConfiguration & config ) : SyncActionNode ( name , config ) {} // We want this method to be called ONCE and BEFORE the first tick() void init ( int arg1 , double arg2 , const std :: string & arg3 ) { _arg1 = ( arg1 ); _arg2 = ( arg2 ); _arg3 = ( arg3 ); } // this example doesn't require any port static PortsList providedPorts () { return {}; } // tick() can access the private members NodeStatus tick () override ; private : int _arg1 ; double _arg2 ; std :: string _arg3 ; }; The way we register and initialize Action_B is slightly different: BehaviorTreeFactory factory ; // The regitration of Action_B is done as usual, but remember // that we still need to call Action_B::init() factory . registerNodeType < Action_B > ( \"Action_B\" ); // Register more custom nodes, if needed. // .... // Create the whole tree auto tree = factory . createTreeFromText ( xml_text ); // Iterate through all the nodes and call init() if it is an Action_B for ( auto & node : tree . nodes ) { // Not a typo: it is \"=\", not \"==\" if ( auto action_B = dynamic_cast < Action_B *> ( node . get () )) { action_B -> init ( 42 , 3.14 , \"hello world\" ); } } // The rest of your code, where you tick the tree, goes here. // ....","title":"Tutorial 8: Additional arguments"},{"location":"tutorial_08_additional_args/#pass-additional-arguments-during-initialization-andor-construction","text":"In every single example we explored so far we were \"forced\" to provide a constructor with the following signature MyCustomNode ( const std :: string & name , const NodeConfiguration & config ); In same cases, it is desirable to pass to the constructor of our class additional arguments, parameters, pointers, references, etc. Many people use blackboards to do that: this is not recomendable. We will just use the word \"arguments\" for the rest of the tutorial. Even if, theoretically, these arguments could be passed using Input Ports, that would be the wrong way to do it if: The arguments are known at deployment-time . The arguments don't change at run-time . The arguments don't need to be set from the XML . If all these conditions are met, using ports or the blackboard is cumbersome and highly discouraged.","title":"Pass additional arguments during initialization and/or construction"},{"location":"tutorial_08_additional_args/#method-1-register-a-custom-builder","text":"Consider the following custom node called Action_A . We want to pass three additional arguments; they can be arbitrarily complex objects, you are not limited to built-in types. // Action_A has a different constructor than the default one. class Action_A : public SyncActionNode { public : // additional arguments passed to the constructor Action_A ( const std :: string & name , const NodeConfiguration & config , int arg1 , double arg2 , std :: string arg3 ) : SyncActionNode ( name , config ), _arg1 ( arg1 ), _arg2 ( arg2 ), _arg3 ( arg3 ) {} // this example doesn't require any port static PortsList providedPorts () { return {}; } // tick() can access the private members NodeStatus tick () override ; private : int _arg1 ; double _arg2 ; std :: string _arg3 ; }; This node should be registered as shown further: BehaviorTreeFactory factory ; // A node builder is a functor that creates a std::unique_ptr<TreeNode>. // Using lambdas or std::bind, we can easily \"inject\" additional arguments. NodeBuilder builder_A = []( const std :: string & name , const NodeConfiguration & config ) { return std :: make_unique < Action_A > ( name , config , 42 , 3.14 , \"hello world\" ); }; // BehaviorTreeFactory::registerBuilder is a more general way to // register a custom node. factory . registerBuilder < Action_A > ( \"Action_A\" , builder_A ); // Register more custom nodes, if needed. // .... // The rest of your code, where you create and tick the tree, goes here. // ....","title":"Method 1: register a custom builder"},{"location":"tutorial_08_additional_args/#method-2-use-an-init-method","text":"Alternatively, you may call an init method before ticking the tree. class Action_B : public SyncActionNode { public : // The constructor looks as usual. Action_B ( const std :: string & name , const NodeConfiguration & config ) : SyncActionNode ( name , config ) {} // We want this method to be called ONCE and BEFORE the first tick() void init ( int arg1 , double arg2 , const std :: string & arg3 ) { _arg1 = ( arg1 ); _arg2 = ( arg2 ); _arg3 = ( arg3 ); } // this example doesn't require any port static PortsList providedPorts () { return {}; } // tick() can access the private members NodeStatus tick () override ; private : int _arg1 ; double _arg2 ; std :: string _arg3 ; }; The way we register and initialize Action_B is slightly different: BehaviorTreeFactory factory ; // The regitration of Action_B is done as usual, but remember // that we still need to call Action_B::init() factory . registerNodeType < Action_B > ( \"Action_B\" ); // Register more custom nodes, if needed. // .... // Create the whole tree auto tree = factory . createTreeFromText ( xml_text ); // Iterate through all the nodes and call init() if it is an Action_B for ( auto & node : tree . nodes ) { // Not a typo: it is \"=\", not \"==\" if ( auto action_B = dynamic_cast < Action_B *> ( node . get () )) { action_B -> init ( 42 , 3.14 , \"hello world\" ); } } // The rest of your code, where you tick the tree, goes here. // ....","title":"Method 2: use an init method"},{"location":"tutorial_09_coroutines/","text":"Async Actions using Coroutines BehaviorTree.CPP provides two easy-to-use abstractions to create an asynchronous Action, i.e. those actions which: Take a long time to be concluded. May return \"RUNNING\". Can be halted . The first class is a AsyncActionNode that executes the tick() method in a separate thread . In this tutorial, we introduce the CoroActionNode , a different action that uses coroutines to achieve similar results. The main reason is that Coroutines do not spawn a new thread and are much more efficient. Furthermore, you don't need to worry about thread-safety in your code... In Coroutines, the user should explicitly call a yield method when he/she wants the execution of the Action to be suspended. CoroActionNode wraps this yield function into a convenient method setStatusRunningAndYield() . The C++ source example The next example can be used as a \"template\" for your own implementation. typedef std :: chrono :: milliseconds Milliseconds ; class MyAsyncAction : public CoroActionNode { public : MyAsyncAction ( const std :: string & name ) : CoroActionNode ( name , {}) {} private : // This is the ideal skeleton/template of an async action: // - A request to a remote service provider. // - A loop where we check if the reply has been received. // - You may call setStatusRunningAndYield() to \"pause\". // - Code to execute after the reply. // - A simple way to handle halt(). NodeStatus tick () override { std :: cout << name () << \": Started. Send Request to server.\" << std :: endl ; TimePoint initial_time = Now (); TimePoint time_before_reply = initial_time + Milliseconds ( 100 ); int count = 0 ; bool reply_received = false ; while ( ! reply_received ) { if ( count ++ == 0 ) { // call this only once std :: cout << name () << \": Waiting Reply...\" << std :: endl ; } // pretend that we received a reply if ( Now () >= time_before_reply ) { reply_received = true ; } if ( ! reply_received ) { // set status to RUNNING and \"pause/sleep\" // If halt() is called, we will NOT resume execution setStatusRunningAndYield (); } } // This part of the code is never reached if halt() is invoked, // only if reply_received == true; std :: cout << name () << \": Done. 'Waiting Reply' loop repeated \" << count << \" times\" << std :: endl ; cleanup ( false ); return NodeStatus :: SUCCESS ; } // you might want to cleanup differently if it was halted or successful void cleanup ( bool halted ) { if ( halted ) { std :: cout << name () << \": cleaning up after an halt() \\n \" << std :: endl ; } else { std :: cout << name () << \": cleaning up after SUCCESS \\n \" << std :: endl ; } } void halt () override { std :: cout << name () << \": Halted.\" << std :: endl ; cleanup ( true ); // Do not forget to call this at the end. CoroActionNode :: halt (); } Timepoint Now () { return std :: chrono :: high_resolution_clock :: now (); }; }; As you may have noticed, the action \"pretends\" to wait for a request message; the latter will arrive after 100 milliseconds . To spice things up, we create a Sequence with two actions, but the entire sequence will be halted by a timeout after 150 millisecond . <root > <BehaviorTree> <Timeout msec= \"150\" > <SequenceStar name= \"sequence\" > <MyAsyncAction name= \"action_A\" /> <MyAsyncAction name= \"action_B\" /> </SequenceStar> </Timeout> </BehaviorTree> </root> No surprises in the main() ... int main () { // Simple tree: a sequence of two asycnhronous actions, // but the second will be halted because of the timeout. BehaviorTreeFactory factory ; factory . registerNodeType < MyAsyncAction > ( \"MyAsyncAction\" ); auto tree = factory . createTreeFromText ( xml_text ); //--------------------------------------- // keep executin tick until it returns etiher SUCCESS or FAILURE while ( tree . tickRoot () == NodeStatus :: RUNNING ) { std :: this_thread :: sleep_for ( Milliseconds ( 10 ) ); } return 0 ; } /* Expected output: action_A: Started. Send Request to server. action_A: Waiting Reply... action_A: Done. 'Waiting Reply' loop repeated 11 times action_A: cleaning up after SUCCESS action_B: Started. Send Request to server. action_B: Waiting Reply... action_B: Halted. action_B: cleaning up after an halt() */","title":"Tutorial 9: Coroutines"},{"location":"tutorial_09_coroutines/#async-actions-using-coroutines","text":"BehaviorTree.CPP provides two easy-to-use abstractions to create an asynchronous Action, i.e. those actions which: Take a long time to be concluded. May return \"RUNNING\". Can be halted . The first class is a AsyncActionNode that executes the tick() method in a separate thread . In this tutorial, we introduce the CoroActionNode , a different action that uses coroutines to achieve similar results. The main reason is that Coroutines do not spawn a new thread and are much more efficient. Furthermore, you don't need to worry about thread-safety in your code... In Coroutines, the user should explicitly call a yield method when he/she wants the execution of the Action to be suspended. CoroActionNode wraps this yield function into a convenient method setStatusRunningAndYield() .","title":"Async Actions using Coroutines"},{"location":"tutorial_09_coroutines/#the-c-source-example","text":"The next example can be used as a \"template\" for your own implementation. typedef std :: chrono :: milliseconds Milliseconds ; class MyAsyncAction : public CoroActionNode { public : MyAsyncAction ( const std :: string & name ) : CoroActionNode ( name , {}) {} private : // This is the ideal skeleton/template of an async action: // - A request to a remote service provider. // - A loop where we check if the reply has been received. // - You may call setStatusRunningAndYield() to \"pause\". // - Code to execute after the reply. // - A simple way to handle halt(). NodeStatus tick () override { std :: cout << name () << \": Started. Send Request to server.\" << std :: endl ; TimePoint initial_time = Now (); TimePoint time_before_reply = initial_time + Milliseconds ( 100 ); int count = 0 ; bool reply_received = false ; while ( ! reply_received ) { if ( count ++ == 0 ) { // call this only once std :: cout << name () << \": Waiting Reply...\" << std :: endl ; } // pretend that we received a reply if ( Now () >= time_before_reply ) { reply_received = true ; } if ( ! reply_received ) { // set status to RUNNING and \"pause/sleep\" // If halt() is called, we will NOT resume execution setStatusRunningAndYield (); } } // This part of the code is never reached if halt() is invoked, // only if reply_received == true; std :: cout << name () << \": Done. 'Waiting Reply' loop repeated \" << count << \" times\" << std :: endl ; cleanup ( false ); return NodeStatus :: SUCCESS ; } // you might want to cleanup differently if it was halted or successful void cleanup ( bool halted ) { if ( halted ) { std :: cout << name () << \": cleaning up after an halt() \\n \" << std :: endl ; } else { std :: cout << name () << \": cleaning up after SUCCESS \\n \" << std :: endl ; } } void halt () override { std :: cout << name () << \": Halted.\" << std :: endl ; cleanup ( true ); // Do not forget to call this at the end. CoroActionNode :: halt (); } Timepoint Now () { return std :: chrono :: high_resolution_clock :: now (); }; }; As you may have noticed, the action \"pretends\" to wait for a request message; the latter will arrive after 100 milliseconds . To spice things up, we create a Sequence with two actions, but the entire sequence will be halted by a timeout after 150 millisecond . <root > <BehaviorTree> <Timeout msec= \"150\" > <SequenceStar name= \"sequence\" > <MyAsyncAction name= \"action_A\" /> <MyAsyncAction name= \"action_B\" /> </SequenceStar> </Timeout> </BehaviorTree> </root> No surprises in the main() ... int main () { // Simple tree: a sequence of two asycnhronous actions, // but the second will be halted because of the timeout. BehaviorTreeFactory factory ; factory . registerNodeType < MyAsyncAction > ( \"MyAsyncAction\" ); auto tree = factory . createTreeFromText ( xml_text ); //--------------------------------------- // keep executin tick until it returns etiher SUCCESS or FAILURE while ( tree . tickRoot () == NodeStatus :: RUNNING ) { std :: this_thread :: sleep_for ( Milliseconds ( 10 ) ); } return 0 ; } /* Expected output: action_A: Started. Send Request to server. action_A: Waiting Reply... action_A: Done. 'Waiting Reply' loop repeated 11 times action_A: cleaning up after SUCCESS action_B: Started. Send Request to server. action_B: Waiting Reply... action_B: Halted. action_B: cleaning up after an halt() */","title":"The C++ source example"},{"location":"tutorials_summary/","text":"Summary of the tutorials T.1: Create your first Behavior Tree This tutorial demonstrates how to create custom ActionNodes in C++ and how to compose them into Trees using the XML language. T.2: Parametrize a Node with Ports TreeNodes can have both Inputs and Outputs Ports. This tutorial demonstrates how to use ports to create parametrized Nodes. T.3: Generic and type-safe Ports This tutorial is an extension of the previous one. It shows how to create and use ports with generic and user-defined types. T.4: Difference between Sequence and ReactiveSequence Reactive ControlNodes can be a very powerful tool to create sophisticated behaviors. This example shows the difference between a standard Sequence and a Reactive one. T.5: How to reuse entire SubTrees Reusability and Composability can be done at the level of a single Node, but also with entire Trees, which can become SubTrees of a \"parent\" Tree. In this tutorial we will also introduce the builtin Loggers. T.6: Remapping of Ports between SubTrees and their parents Any Tree/SubTree in the system has its own isolated BlackBoard. In this tutorial we extend the concept or Ports to SubTrees, using port remapping. T.7: How to wrap legacy code in a non intrusive way This tutorial shows one of the many possible ways to wrap an existing code into the BehavioTree.CPP infrastructure. T.8: Passing arguments to Nodes without Ports If your custom Node has a lot of ports, it is probably a sign that you didn't understand the problem that Ports are supposed to solve ;) In this tutorial, we show how to pass arguments to a custom Node class without polluting your interfaces with pointless Input Ports. T.9: Asynchronous actions with Coroutines Coroutines are a powerful tool to create asynchronous code. In this tutorial, we outline the typical design pattern to use when you implement an asynchronous Action using CoroActionNode .","title":"Summary"},{"location":"tutorials_summary/#summary-of-the-tutorials","text":"","title":"Summary of the tutorials"},{"location":"tutorials_summary/#t1-create-your-first-behavior-tree","text":"This tutorial demonstrates how to create custom ActionNodes in C++ and how to compose them into Trees using the XML language.","title":"T.1: Create your first Behavior Tree"},{"location":"tutorials_summary/#t2-parametrize-a-node-with-ports","text":"TreeNodes can have both Inputs and Outputs Ports. This tutorial demonstrates how to use ports to create parametrized Nodes.","title":"T.2: Parametrize a Node with Ports"},{"location":"tutorials_summary/#t3-generic-and-type-safe-ports","text":"This tutorial is an extension of the previous one. It shows how to create and use ports with generic and user-defined types.","title":"T.3: Generic and type-safe Ports"},{"location":"tutorials_summary/#t4-difference-between-sequence-and-reactivesequence","text":"Reactive ControlNodes can be a very powerful tool to create sophisticated behaviors. This example shows the difference between a standard Sequence and a Reactive one.","title":"T.4: Difference between Sequence and ReactiveSequence"},{"location":"tutorials_summary/#t5-how-to-reuse-entire-subtrees","text":"Reusability and Composability can be done at the level of a single Node, but also with entire Trees, which can become SubTrees of a \"parent\" Tree. In this tutorial we will also introduce the builtin Loggers.","title":"T.5: How to reuse entire SubTrees"},{"location":"tutorials_summary/#t6-remapping-of-ports-between-subtrees-and-their-parents","text":"Any Tree/SubTree in the system has its own isolated BlackBoard. In this tutorial we extend the concept or Ports to SubTrees, using port remapping.","title":"T.6: Remapping of Ports between SubTrees and their parents"},{"location":"tutorials_summary/#t7-how-to-wrap-legacy-code-in-a-non-intrusive-way","text":"This tutorial shows one of the many possible ways to wrap an existing code into the BehavioTree.CPP infrastructure.","title":"T.7: How to wrap legacy code in a non intrusive way"},{"location":"tutorials_summary/#t8-passing-arguments-to-nodes-without-ports","text":"If your custom Node has a lot of ports, it is probably a sign that you didn't understand the problem that Ports are supposed to solve ;) In this tutorial, we show how to pass arguments to a custom Node class without polluting your interfaces with pointless Input Ports.","title":"T.8: Passing arguments to Nodes without Ports"},{"location":"tutorials_summary/#t9-asynchronous-actions-with-coroutines","text":"Coroutines are a powerful tool to create asynchronous code. In this tutorial, we outline the typical design pattern to use when you implement an asynchronous Action using CoroActionNode .","title":"T.9: Asynchronous actions with Coroutines"},{"location":"xml_format/","text":"Basics of the XML schema In the first tutorial this simple tree was presented. <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence name= \"root_sequence\" > <SaySomething name= \"action_hello\" message= \"Hello\" /> <OpenGripper name= \"open_gripper\" /> <ApproachObject name= \"approach_object\" /> <CloseGripper name= \"close_gripper\" /> </Sequence> </BehaviorTree> </root> You may notice that: The first tag of the tree is <root> . It should contain 1 or more tags <BehaviorTree> . The tag <BehaviorTree> should have the attribute [ID] . The tag <root> should contain the attribute [main_tree_to_execute] . The attribute [main_tree_to_execute] is mandatory if the file contains multiple <BehaviorTree> , optional otherwise. Each TreeNode is represented by a single tag. In particular: The name of the tag is the ID used to register the TreeNode in the factory. The attribute [name] refers to the name of the instance and is optional . Ports are configured using attributes. In the previous example, the action SaySomething requires the input port message . In terms of number of children: ControlNodes contain 1 to N children . DecoratorNodes and Subtrees contain only 1 child . ActionNodes and ConditionNodes have no child . Ports Remapping and pointers to Blackboards entries As explained in the second tutorial input/output ports can be remapped using the name of an entry in the Blackboard, in other words, the key of a key/value pair of the BB. An BB key is represented using this syntax: {key_name} . In the following example: the first child of the Sequence prints \"Hello\", the second child reads and writes the value contained in the entry of the blackboard called \"my_message\"; <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence name= \"root_sequence\" > <SaySomething message= \"Hello\" /> <SaySomething message= \"{my_message}\" /> </Sequence> </BehaviorTree> </root> Compact vs Explicit representation The following two syntaxes are both valid: <SaySomething name= \"action_hello\" message= \"Hello World\" /> <Action ID= \"SaySomething\" name= \"action_hello\" message= \"Hello World\" /> We will call the former syntax \" compact \" and the latter \" explicit \". The first example represented with the explicit syntax would become: <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence name= \"root_sequence\" > <Action ID= \"SaySomething\" name= \"action_hello\" message= \"Hello\" /> <Action ID= \"OpenGripper\" name= \"open_gripper\" /> <Action ID= \"ApproachObject\" name= \"approach_object\" /> <Action ID= \"CloseGripper\" name= \"close_gripper\" /> </Sequence> </BehaviorTree> </root> Even if the compact syntax is more convenient and easier to write, it provides too little information about the model of the TreeNode. Tools like Groot require either the explicit syntax or additional information. This information can be added using the tag <TreeNodeModel> . To make the compact version of our tree compatible with Groot, the XML must be modified as follows: <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence name= \"root_sequence\" > <SaySomething name= \"action_hello\" message= \"Hello\" /> <OpenGripper name= \"open_gripper\" /> <ApproachObject name= \"approach_object\" /> <CloseGripper name= \"close_gripper\" /> </Sequence> </BehaviorTree> <!-- the BT executor don't require this, but Groot does --> <TreeNodeModel> <Action ID= \"SaySomething\" > <input_port name= \"message\" type= \"std::string\" /> </Action> <Action ID= \"OpenGripper\" /> <Action ID= \"ApproachObject\" /> <Action ID= \"CloseGripper\" /> </TreeNodeModel> </root> XML Schema available for explicit version You can download the XML Schema here: behaviortree_schema.xsd . Subtrees As we saw in this tutorial , it is possible to include a Subtree inside another tree to avoid \"copy and pasting\" the same tree in multiple location and to reduce complexity. Let's say that we want to incapsulate few action into the behaviorTree \" GraspObject \" (being optional, attributes [name] are omitted for simplicity). <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence> <Action ID= \"SaySomething\" message= \"Hello World\" /> <SubTree ID= \"GraspObject\" /> </Sequence> </BehaviorTree> <BehaviorTree ID= \"GraspObject\" > <Sequence> <Action ID= \"OpenGripper\" /> <Action ID= \"ApproachObject\" /> <Action ID= \"CloseGripper\" /> </Sequence> </BehaviorTree> </root> We may notice as the entire tree \"GraspObject\" is executed after \"SaySomething\". Include external files Since version 2.4 . You can include external files in a way that is similar to #include in C++. We can do this easily using the tag: <include path= \"relative_or_absolute_path_to_file\" > using the previous example, we may split the two behavior trees into two files: <!-- file maintree.xml --> <root main_tree_to_execute = \"MainTree\" > <include path= \"grasp.xml\" /> <BehaviorTree ID= \"MainTree\" > <Sequence> <Action ID= \"SaySomething\" message= \"Hello World\" /> <SubTree ID= \"GraspObject\" /> </Sequence> </BehaviorTree> </root> <!-- file grasp.xml --> <root main_tree_to_execute = \"GraspObject\" > <BehaviorTree ID= \"GraspObject\" > <Sequence> <Action ID= \"OpenGripper\" /> <Action ID= \"ApproachObject\" /> <Action ID= \"CloseGripper\" /> </Sequence> </BehaviorTree> </root> Note for ROS users If you want to find a file inside a ROS package , you can use this syntax: <include ros_pkg=\"name_package\" path=\"path_relative_to_pkg/grasp.xml\"/>","title":"The XML format"},{"location":"xml_format/#basics-of-the-xml-schema","text":"In the first tutorial this simple tree was presented. <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence name= \"root_sequence\" > <SaySomething name= \"action_hello\" message= \"Hello\" /> <OpenGripper name= \"open_gripper\" /> <ApproachObject name= \"approach_object\" /> <CloseGripper name= \"close_gripper\" /> </Sequence> </BehaviorTree> </root> You may notice that: The first tag of the tree is <root> . It should contain 1 or more tags <BehaviorTree> . The tag <BehaviorTree> should have the attribute [ID] . The tag <root> should contain the attribute [main_tree_to_execute] . The attribute [main_tree_to_execute] is mandatory if the file contains multiple <BehaviorTree> , optional otherwise. Each TreeNode is represented by a single tag. In particular: The name of the tag is the ID used to register the TreeNode in the factory. The attribute [name] refers to the name of the instance and is optional . Ports are configured using attributes. In the previous example, the action SaySomething requires the input port message . In terms of number of children: ControlNodes contain 1 to N children . DecoratorNodes and Subtrees contain only 1 child . ActionNodes and ConditionNodes have no child .","title":"Basics of the XML schema"},{"location":"xml_format/#ports-remapping-and-pointers-to-blackboards-entries","text":"As explained in the second tutorial input/output ports can be remapped using the name of an entry in the Blackboard, in other words, the key of a key/value pair of the BB. An BB key is represented using this syntax: {key_name} . In the following example: the first child of the Sequence prints \"Hello\", the second child reads and writes the value contained in the entry of the blackboard called \"my_message\"; <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence name= \"root_sequence\" > <SaySomething message= \"Hello\" /> <SaySomething message= \"{my_message}\" /> </Sequence> </BehaviorTree> </root>","title":"Ports Remapping and pointers to Blackboards entries"},{"location":"xml_format/#compact-vs-explicit-representation","text":"The following two syntaxes are both valid: <SaySomething name= \"action_hello\" message= \"Hello World\" /> <Action ID= \"SaySomething\" name= \"action_hello\" message= \"Hello World\" /> We will call the former syntax \" compact \" and the latter \" explicit \". The first example represented with the explicit syntax would become: <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence name= \"root_sequence\" > <Action ID= \"SaySomething\" name= \"action_hello\" message= \"Hello\" /> <Action ID= \"OpenGripper\" name= \"open_gripper\" /> <Action ID= \"ApproachObject\" name= \"approach_object\" /> <Action ID= \"CloseGripper\" name= \"close_gripper\" /> </Sequence> </BehaviorTree> </root> Even if the compact syntax is more convenient and easier to write, it provides too little information about the model of the TreeNode. Tools like Groot require either the explicit syntax or additional information. This information can be added using the tag <TreeNodeModel> . To make the compact version of our tree compatible with Groot, the XML must be modified as follows: <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence name= \"root_sequence\" > <SaySomething name= \"action_hello\" message= \"Hello\" /> <OpenGripper name= \"open_gripper\" /> <ApproachObject name= \"approach_object\" /> <CloseGripper name= \"close_gripper\" /> </Sequence> </BehaviorTree> <!-- the BT executor don't require this, but Groot does --> <TreeNodeModel> <Action ID= \"SaySomething\" > <input_port name= \"message\" type= \"std::string\" /> </Action> <Action ID= \"OpenGripper\" /> <Action ID= \"ApproachObject\" /> <Action ID= \"CloseGripper\" /> </TreeNodeModel> </root> XML Schema available for explicit version You can download the XML Schema here: behaviortree_schema.xsd .","title":"Compact vs Explicit representation"},{"location":"xml_format/#subtrees","text":"As we saw in this tutorial , it is possible to include a Subtree inside another tree to avoid \"copy and pasting\" the same tree in multiple location and to reduce complexity. Let's say that we want to incapsulate few action into the behaviorTree \" GraspObject \" (being optional, attributes [name] are omitted for simplicity). <root main_tree_to_execute = \"MainTree\" > <BehaviorTree ID= \"MainTree\" > <Sequence> <Action ID= \"SaySomething\" message= \"Hello World\" /> <SubTree ID= \"GraspObject\" /> </Sequence> </BehaviorTree> <BehaviorTree ID= \"GraspObject\" > <Sequence> <Action ID= \"OpenGripper\" /> <Action ID= \"ApproachObject\" /> <Action ID= \"CloseGripper\" /> </Sequence> </BehaviorTree> </root> We may notice as the entire tree \"GraspObject\" is executed after \"SaySomething\".","title":"Subtrees"},{"location":"xml_format/#include-external-files","text":"Since version 2.4 . You can include external files in a way that is similar to #include in C++. We can do this easily using the tag: <include path= \"relative_or_absolute_path_to_file\" > using the previous example, we may split the two behavior trees into two files: <!-- file maintree.xml --> <root main_tree_to_execute = \"MainTree\" > <include path= \"grasp.xml\" /> <BehaviorTree ID= \"MainTree\" > <Sequence> <Action ID= \"SaySomething\" message= \"Hello World\" /> <SubTree ID= \"GraspObject\" /> </Sequence> </BehaviorTree> </root> <!-- file grasp.xml --> <root main_tree_to_execute = \"GraspObject\" > <BehaviorTree ID= \"GraspObject\" > <Sequence> <Action ID= \"OpenGripper\" /> <Action ID= \"ApproachObject\" /> <Action ID= \"CloseGripper\" /> </Sequence> </BehaviorTree> </root> Note for ROS users If you want to find a file inside a ROS package , you can use this syntax: <include ros_pkg=\"name_package\" path=\"path_relative_to_pkg/grasp.xml\"/>","title":"Include external files"}]}